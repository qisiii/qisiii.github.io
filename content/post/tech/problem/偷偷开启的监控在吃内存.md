+++
title = "偷偷开启的监控在吃内存"
description = ""
date = 2023-12-10
image = ""
draft = false
slug = "springActuator_fullgc"
tags = ['线上异常']
categories = ['tech']
+++

## 整体复盘：

一个不算普通的周五中午，同事收到了大量了cpu异常的报警。根据报警表现和通过arthas查看，很明显的问题就是内存不足，疯狂无效gc。而且结合arthas和gc日志查看，老年代打满了，gc不了一点。既然问题是内存问题，那么老样子，通过jmap和heap dump 文件分析。

不感兴趣的可以直接看结论

通过jmap命令查看的类似下图，并没有项目中明显的自定义类，而占空间最大的又是char数组，当时线上占900M左右，整个老年代也就1.8个G；此时dump文件同事还在下载，网速较慢。

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTRmMjkyMTVkMWIyOTRiY2YwZWVkYzU2OWJlNGQxMmRfcGZ5eUdTd1lHN3lqNDNxc094TzVGdndjc0pDejlXODZfVG9rZW46VjBpWGJ1eTlwb09ta3B4V2lNNmNWRFRNbmZkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

通过业务日志查看，很多restTempalte请求报错，根据报错信息可知是某xx认证过期了，导致接收到回调，业务处理时调接口报错了；查询数据库，大概有20多万回调。根据过期时间和内存监控，大概能对的上号，表明内存异常和这个认证过期有关。怀疑度最高的只有回调以及回调补偿任务，但是一行一行代码看过去，并不觉得有什么异常。

~~在dump文件下载完之后，使用jvisualvm分析，最多的char里大部分都是一些请求的路径，如“example/test/1"，”“example/test/2"之类的，都是接口统一，但是参数不一样，因为是GET请求，所以实际路径都不一样。Jvisualvm点击gc_root又一直计算不出来，在等待计算的过程中，一度走了弯路（百度搜索到ImmutableTag这个类在skywalking有用过，但skywalking由于是jar包进行代理，项目中不存在对应的源码，所以又不得不下载公司的jar包反编译，然后去找http相关插件里翻源码，只是为了看一下ImmutableTag的具体结构）；此时，我们大概归纳到是http的监控在统计一些指标物料时，没有释放接口路径所引用的对象导致老年代打满）。 在gc_root终于计算出来之后，更是肯定了这个想法，但是hikari怎么可能监听http呢？~~

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE1NDliNDRhMjBkOGY5YTFiODI0YmI2OWEyNmYzNTFfeDBIU2hqQUZLWDFLdXNvazRxbm54Yk9LMWNHdExzUjhfVG9rZW46R3BCS2J3cU81b0h6YzZ4c1AzdmNoQ2EzbjZnXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

于是又现下载jprofiler，通过jprofiler的聚类，确定了一定是这个Meter导致的，而通过JProfile的分析，终于定位到是

org.springframework.boot.actuate.metrics.web.client.MetricsClientHttpRequestInterceptor#intercept这个类。然后发现，MetricsClientHttpRequestInterceptor 持有一个meterRegistry，里面核心是个map，所以一定是map没有清除。和我们最开始想的skywalking不一样，是springboot配套的监控，根据依赖分析，发现是有次需求引入了redisson-spring-boot-starter，而redisson依赖了spring-boot-starter-actuator，这东西默认启动了，会拦截所有的RestTempalte请求，然后记录一些指标。

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY4ZjY3NTAzNzhjOWI4MGRhMWRlZTBkZGM1ZDk4MGVfWWlrU2ZhVG0zd2VWN3hUUTV3VFhXaHZXczZKeGZwMW5fVG9rZW46VkplVWJ2T25mb3JTQmR4YzBvRWNNSlE3bjVkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmNhZjRjNjViNGJjMWRhOGE4NzI2MjViZGVhNTY4NDZfRlNQV0VoZUJSM01JMHBRNDEzQ0ZzWUNUV29xd1o3WDhfVG9rZW46SmhOTWJGSEUxb25wUEh4TmZlWGNPRm9rbjFlXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

所以问题变成了，为什么map没有清掉已经执行完的请求？

我之前并没有研究过spring的actuator，只是看过skywalking的流程，所以我以为也和skywalking一样，记录然后上报，上报之后删除本地的。所以当时怀疑，难道是和我们请求都异常了有关，但是正如下面的代码，无论是否异常，都是执行finnally，所以又不太可能。

```Java
ClientHttpResponse response = null;
try {
   response = execution.execute(request, body);
   return response;
}
finally {
   try {
      getTimeBuilder(request, response).register(this.meterRegistry).record(System.nanoTime() - startTime,
            TimeUnit.NANOSECONDS);
   }
   catch (Exception ex) {
      logger.info("Failed to record metrics.", ex);
   }
   if (urlTemplate.get().isEmpty()) {
      urlTemplate.remove();
   }
}
```

而在我自己尝试复现之后，micrometer的指标根本不会被自动清除，生命周期和应用的生命周期一样。因为并不存在上报，数据全部在内存（虽然可以导出到数据库，但并没有深入研究）。其实也合理，因为如果要通过Grafana等可视化平台查看的时候，我们也希望查看任意时刻的监控。不过看代码应该是有留一些手动删除的，应该是页面操作之类的才会触发。

## 结论

**所以到此为止，可以定结论，那就是因为引入了redisson-spring-boot-starter，导致不知情引入了spring-boot-starter-actuator。**

因此默认开启了http.client.request指标的监控，关于http.client.request，有一个属性是maxUriTags，默认值是100，其作用是限制meterMap里**uri**的个数。但是maxUriTags起作用的地方MeterFilter没有生效。

由于maxUriTags没有生效，导致监控信息里的uri因为业务大量的GET请求中存在唯一id，本身就很占内存。压死内存的最后稻草是认证过期和补偿任务。补偿任务为保证及时性一直在频繁执行，而接口的uri里两个变量（token和uniId）导致meterMap里的key不重复，一直在插入，20万回调，token两小时更新一次，持续了两天，最终产生了124万条字符串，被map持有，无法回收。

## 解决方案

1. 不需要监控

直接排除掉**spring-boot-starter-actuator**

2. 需要监控但不需要http.client.request指标

```Java
management:
  metrics:
    web:
      client:
        request:
          autotime:
            enabled: false
```

3. 需要http.client.request指标

jar包升到2.5.1或以上

```Java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-actuator-autoconfigure</artifactId>
    <version>2.5.1</version>
</dependency>
```

## 复现：

新建测试项目

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFjOGNhNGRkNjk0YWRiZmU1NGNjYTlkZDJlYThkYzdfMzVuMG84aTBueWtNSWE4TXh1YndGcWJzY0Q5Y2ZEckVfVG9rZW46Rm9KaWIzWjFQb040TnV4QzF6dmNyTEdVbk1nXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

相关代码和配置如下

```Java
@SpringBootApplication
@Slf4j
public class Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext run = SpringApplication.run(Application.class);
        RestTemplate bean = run.getBean(RestTemplate.class);
        for (int i = 0; i < 300000; i++) {
            try {
                String forObject = bean.getForObject("http://localhost:9999/first/echo?i="+i, String.class);
            }catch (Exception e){
                log.error("执行"+i+"次");
            }
        }
    }
}

@Configuration
public class RestTemplateTestConfig {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder){
        return builder.build();
    }
}

<dependencies>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-boot-starter</artifactId>
        <version>3.13.1</version>
    </dependency>
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
    </dependency>
</dependencies>

server:
  port: 8080
spring:
  redis:
    host: 101.43.164.254
    password: hkc810215
#management:
#  endpoints:
#    web:
#      exposure:
#        include: "metrics"
#  metrics:
#    web:
#      client:
#        request:
#          autotime:
#            enabled: false
```

启动项目通过jconsole查看整个堆的监控和老年代监控分别如下，可以看出老年代一直在增长，并不会回收，

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQzNjdhN2QxY2NhZTJmNGRmNjAzNDNhMjMxMzk4NmZfZFJKblUxVDlCSGxHcXVPMk5uSnd3Z2lPbFVVeFF0d3dfVG9rZW46TE93T2JQYmFEb3pQRzR4WDg5Y2NmVFJvbjdmXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRkNzNlMzA5NzVkZmY4NGRmMTAxNGIxY2EwNjExZWJfZkV0Rnh3MDJ3SnhXT0E1bmd6NGc0TlNqY3d5dUZjNHdfVG9rZW46S3E4N2JXM3Jrb0FWVEN4U3ZYZmNQd2xObnRjXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

甚至手动触发GC，老年代也回收不了

```Java
[Full GC (System.gc()) [Tenured: 195217K->195457K(204800K), 0.3975261 secs] 233021K->195457K(296960K), [Metaspace: 30823K->30823K(33152K)], 0.3976223 secs] [Times: user=0.39 sys=0.00, real=0.40 secs] 
```

通过jprofiler确定主要是meterMap占据内存了，最多的都是字符串。

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE0YTcxM2YzOWZlZDc1YjU1N2M4MTEyY2I1ZmFiNTFfYkx5SWE2YVR5MmF1M3l4RGZ5ZHYyaUxyUWRpdkJSMnRfVG9rZW46U3Z0MmJjNGYxb3dTV0N4YlR6TWNhTVppbnhkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZjZDIwZDFiNWVkNmIwZThkN2RhODVlMTAxMWQ0NDZfcnFtdThnaDRkNzVWNVo3cWM0aVJ1T2JyU0x2ZUo3TnhfVG9rZW46UjJobWJDUEVrb0lnRjB4RXE5VWNWelUzbkpjXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

## 分析

### actuator导致rest启动了metrics记录

在使用RestTemplateBuilder构建RestTemplate的时候，会触发懒加载的RestTemplateAutoConfiguration里的RestTemplateBuilderConfigurer，在此期间，config中会注入RestTempalteCustomizer类型的bean。

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNiMGU0ZjdmYTA4MTYyMGE0NDI2MjE5NWY0NWYxNThfZ3IxVTB2WGd0T004SGFWcXVOWERKSWFMYXRiN2xoWFhfVG9rZW46T3lrZ2JpcUs5b0RGaWx4YWh6a2MxWExLblZoXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

而项目中引用了redisson-spring-boot-starter，从依赖分析可以看出间接引用了actuator相关的包。

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmM3Y2JiZjcyOTQwMDg0NmRkMjIyZjI1ZmVlYTM0ZDNfZ2ZCaDRzYllST0ZJREdhVm1MbzRuVVNsc3p6Z1lHU1ZfVG9rZW46UVZqSGJMVzlqbzVXUFB4b1pzSWM2N3NpbkZkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

这导致会在RestTemplateMetricsConfiguration配置类中实例化一个叫做MetricsRestTemplateCustomizer的bean，这个bean会通过上面的restTepalteBuilderConfigurer.configure方法给restTemplate添加拦截器MetricsClientHttpRequestInterceptor。

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWIzNDJiM2YxZjk3MjNmZDY0N2ZhNGRmZGE5N2QzZjJfZkpuNjdKN29sRnk0Q25teXB5dnFOSW05SG1Uak5lV3NfVG9rZW46UGlHQWJFTlV5b3gweGR4SUkwUGNRVFZybjFjXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

拦截器的intercept方法会在finnally中最终记录此次请求的一些指标

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjI2MzBkYzE2ZmRjMjVmNjJmZWEwOGQ0ZDA0OGI5ZWVfWXJ3TWdCZmdnNFVMYVpka2NjVmhaS0V6Yjh2SEUxUWlfVG9rZW46Qk5ka2JRTUpDb0dLUjZ4aGd4OGMya2xNbnI0XzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

io.micrometer.core.instrument.Timer.Builder#register->

io.micrometer.core.instrument.MeterRegistry#time->

io.micrometer.core.instrument.MeterRegistry#registerMeterIfNecessary->

io.micrometer.core.instrument.MeterRegistry#getOrCreateMeter{

meterMap.put(mappedId, m);

}

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGZiNGI2MzY3NTYzZjcxYmY5OTg0YTBkN2MwOGQxYmNfNGJ3ajRLUmN6UmFnRjR5NVRYS0dDaXBNYUxLbTlmZFVfVG9rZW46VDlLa2JMUTJibzN4clN4VlY0WmNqbHI1bnVnXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

最终存到了是SimpleMeterRegistry这个bean的meterMap中去，这个bean也是actuator-autoconfigure自动注入的

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM5NTMyMDIxZWIzNDlhODU3YTRjYjA5NDY2OTVjN2JfblFpQWJLMnJnTTBRNmJ5N05XekhRZXB2WEFkMHZtSjFfVG9rZW46RGYzQ2JseFdCb3JlOWt4MnhKMmNkZmFsbnVVXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

但是到目前为止，只是启动了metrics记录，假如maxUriTags有效的话，会在超过100条记录后getOrCreateMeter方法里的accept这里过滤掉，并不会走到下面的meterMap.put(mappedId, m)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjAwZGJjN2Y5OTBjMWE0ZjY3NTZkZDM5ZDc5MmQ4OTRfWTdsTzFjRktlTWp3RG1UYTRBVDFGUmlpT0kwNnlNUU9fVG9rZW46V2xST2JUS3Mzb1M4M1Z4R0FQb2NDVFpIbmNjXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

### 为什么maxUriTags没有生效？

maxUriTags只在下图这个位置使用了，作用是构建了一个MeterFilter，根据debug我们可以确定bean是产生了的

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzVmOGI5Y2FiNzdlNTc3ZTc2OTNhZjM2MTlmZTc3YjdfV3lKS3YyaXg2RzN6TVhlTlBRNW81emU4NU1vM2lXY09fVG9rZW46UkJ1d2JIeVpwb2QyaTZ4aTNKWWN1dUdrbmljXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

但是在accept这里打上断点，再触发一些请求可以发现，代码并不会走到这里

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGI5YWM5OTNiMDM0YzViMzRiNDJjZDc1OTU1NGQyNmRfME11aG1nY0J0d1V1RlA0SUFyeDhwbXJaWlFCN3ZBQjFfVG9rZW46WWh1SWJZQjBBb2pqVXB4VGZxbWNIckdnblVkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

往上跟，没有走到这里的情况只能是filters里没有这个MeterFilter，但我们刚才又确定metricsHttpCLientUriTagFilter这个bean是产生了的，那么就只能是没有添加到filters，也就是没有调用过meterFilter

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2UzZDNlNTZhNThkMDk1N2JmMmQ4NjlkMGMxMjI5MDdfQ2hYVUJqWUw3bjJqOUFUTVR5QUluRW1TallQSTg3bHZfVG9rZW46VThVZGJIREdNbzVBVEh4V2xrR2NyekJjbmtkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjQ2Yjc3YTJjNmY3NzU2YzgzNTJhYmY3NTc0YmJlMmZfZjJiNWhjdzZWbVF0NGJmQjJiV3RvbUgwUWpxOXhibk9fVG9rZW46S3BqTmJSTVRzb1pSVnB4QU5tUGNyc3JBbmNnXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

从meterFilter往上只有可能是addFilters，一层一层往上最终到了MeterRegistryPostProcessor#postProcessAfterInitialization这个方法

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2Y5MTk1YjM5ZTM1NTc0NGQ3MTNiMGQ3MmRhZWQ5OWJfVE4yS2xaUjlZMFROZXBJbEVFdmVKVDdiQW1jdlpwenFfVG9rZW46WGkzSmJFcG4xb3RjYWZ4T283MmNYVEZGbm8xXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmExMmUxOTMxMmNhNDE3ZDM3M2Q5ZmVjNDBkNjQwMWVfV2dqdWVrcjVmMUZ6QlhadTlYR01vRXJpcmJiMm5YcGNfVG9rZW46SmxoWmJEQUl5b2lNbGZ4a2dGQ2M5STFWbnlnXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBiNGJjMDM5OWNiZjllOWJlZjYyNjhmMWEzYzVjNTNfdE1KM2xYdEJRanVjdTdEWEl2cW93VWlhbm02VFZvZmJfVG9rZW46TjZwSmJ1VjMzb050eHJ4Y0ZIVWMxam9sbkRkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

我们上面说过负责记录的bean叫做simpleMeterRegistry，但是我们在这里打上条件断点发现并没有走到这里

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTkxNTg5Yjk5ZTIzNTQ4MTYxZGMyN2ExZGJkZDYxYTRfRTJCWHd5Nm5mc0RMZlIyUm9rWEJMZzJqVkI0V0hZQ09fVG9rZW46UlB2MGJEVzVvbzVuZjl4Qlh0S2NRQmxkbmhkXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

找到SimpleMeterRegistry和MeterRegistryPostProcessor这两个bean注入的地方打断点观察，都产生了，且MeterRegistryPostProcessor比SimpleMeterRegistry产生的要早

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBjNGRjMzc3ZmZmMzQyZWNiNWJmMTBjMzE3OTIxZDJfdFE3N2gycDRUT00yamw2dXVtYlgyTEtXcXJvaEVrb3pfVG9rZW46Rkd6NmJFeEdnb2xjeDF4TzNVU2MxaXRqbk9EXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM5NWY1NWE2ZmI0YjQyNzViYmM5Nzk2YWRmNWE0MTJfN1lzYWxRVmI5ak1rbDRjdGZsR3dnU2JrM1R0anBaNElfVG9rZW46UGoyamJBY1JQb1Nac2R4UmtabGM5UVBEbklnXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

理论上没问题，但现在确实没走到，所以只能在SimpleMeterRegistry产生的时候在org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization打断点，然后可以发现，在simpleMeterRegistry实例化快结束的时候，调用后处理器时this.beanPostProcessors确实没有MeterRegistryPostProcessor

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM0ZWJjOWViMzcwOTE4YjY2NzM5OWE1Y2RjOTJiMzlfU2pwQUVNNW9SdU1zdkNpclZXRjV5R25jdHhpQktOc2tfVG9rZW46RHBFeGJsZlVDb0V2bnZ4Szc2cGNYSzdhbjJMXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNlMDA1MmE3NThhYzQ5YTBkNjRlYjc4OWQ0MzE5ZDBfVXpGSEV4WlloaUZpWmlBcUJnYVhMdnBQb0J0VXYyOHFfVG9rZW46U0JsdGJ1NjVmb3gzNkl4VDNWTmNZd0czbmdoXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

一般来说，postPorcessor的bean注入是在refresh方法的registerBeanPostProcessors中，是早于普通bean的实例化

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWM1MTA4YjZiN2Q3NDFiNWI0MGU0MzJkNjk2Yjk1MDZfQVZuTUZCZmVuNGY5bTRqUEZnSlpSSnZkZ1hkNW5LVXlfVG9rZW46UHVId2JWR3Bvb2FwQmN4MGYyT2NxeGp2bnhjXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

所以simpleMeterRegistry实例化的时候没有MeterRegistryPostProcessor是不合理的情况，定位simpleMeterRegistry是何时实例化的成了关键问题

#### simpleMeterRegistry的实例化时机

在new SimpleMeterRegistry这里打上断点观察堆栈发现，simpleMeterRegistry是MetricsRepositoryMethodInvocationListener的参数，MetricsRepositoryMethodInvocationListener则是metricsRepositoryMethodInvocationListenerBeanPostProcessor的参数

所以是在实例化metricsRepositoryMethodInvocationListenerBeanPostProcessor这个处理器的时候，因为依赖导致先实例化了simpleMeterRegistry这个bean

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmIzMjYwYzdlNTg4ODRiYWUzZDkzZTM5ZGY4NjQxMTBfTlNoRng5YWF3YkUwR1RubWlTMERVb2phVzVHU0UyNjJfVG9rZW46V3VoNmI4OHJJbzFDQ014WURndGNqYmtnbjZiXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjU3N2FiYTg2ZDNjNmRhNWZiYjM0NWE5NzIyOTAzZTFfMU9iZm54MVdTeHFJMU1YblQ4VkRIVjVaaU9xMTJqTGxfVG9rZW46QkJpZWJsUmhVb2VROTF4SjVBVGM1RDZWbnNoXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU3MDk5NTIzZjlhYzg4ZGIzY2MwY2ZkYTE1OTY5OTlfczBGWGtnc0k3QUxqTXdTcFlzNFVJT1JJWkxzcUpnNWxfVG9rZW46Vk1PM2JBM0w0b2xzczB4QTlJNWN3TEpWbktiXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWEyNzJiNWEzOWI0NDExN2M3MTI4YmRkZTUyNjNlZDFfUWRaeFRKdFl0Nm15VUpzUVlJYTZLa0wyYmNRaFFTcThfVG9rZW46V09QS2JRY2FFb2VGTU14ZG13dGNSdlBTbmNnXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

依赖，导致实例化了SimpleMeterRegistry，而这个时候由于没有注册，所以SimpleMeterRegistry在执行applyBeanPostProcessorsAfterInitialization时就执行不到meterRegistryPostProcessor了

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjNkNTk1OTgzNDczZTZlMjdhY2EwMjUxNGZmODZjYmZfQ2NEUWZBZzVYeXkzaE9aQVRrRW1JM2xyc0FvSnhHSVhfVG9rZW46TXF5WWJweVUwb1lQdW14TXZMS2NLMDNobmNrXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZlMDhjMmM1MmZkZDg2MzRmOTNmOTk0ZTI0YTQzOGRfdVo1ZEdpMUtWVzkwUE9odVZEQlhnMUZpTkk0d3dvR0lfVG9rZW46S1k3dGJPRGJyb0NnOUV4QVVKSGNzSThqbmJlXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

spring已经修复了这个问题，spring-boot-actuator-autoconfigure版本大于2.5.0的都已经没有问题了。解决方案

2.5.1 版本中，添加了一个这个ObjectProvider，在源头上不会立即把依赖的bean初始化完

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ0MTAxOTk3NTU5Mjk3YzZmNjg3NTI4ZTcyZDBlMDlfaWZubTViQTJia3ppeWpwWXpLRjdicTRFeGtEeFVsVGVfVG9rZW46RTFYcWJSTU5yb3hJc294aG11TmM1akxZbkpoXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQ5ZGUzNTllNTAzNzY1MTE5MTI2ZTMyNDc3NWRjYTVfVFJjUTVXNzVqQm9LaGU0NUNnemtUSVEwWGZxeG1LQTNfVG9rZW46TkNsNGJkbXQ4b2xyc3F4bUlFb2NNUmlobjhnXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

2.5.0 版本

![](https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMzZWRiN2FiZDU1MDI3NzMyZTA4NjNiZTdkMTdjYzhfWXRmNVloMlU0WENiNm9rMjI1QW54UUd3YndYVmNEOFlfVG9rZW46T2hMQWJXSHg0b05QRGJ4NzFseGNVN3ZtbjlmXzE3MjMzNjIwNzk6MTcyMzM2NTY3OV9WNA)

```Java
public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
      @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

   descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
   if (Optional.class == descriptor.getDependencyType()) {
      return createOptionalDependency(descriptor, requestingBeanName);
   }
   //由于使用了ObjectProvider，所以这里只是返回了一个DependencyObjectProvider
   else if (ObjectFactory.class == descriptor.getDependencyType() ||
         ObjectProvider.class == descriptor.getDependencyType()) {
      return new DependencyObjectProvider(descriptor, requestingBeanName);
   }
   else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
      return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
   }
   else {
   //2.5.0版本中会在这个方法加载入参依赖的bean
      Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
            descriptor, requestingBeanName);
      if (result == null) {
         result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
      }
      return result;
   }
}
```
