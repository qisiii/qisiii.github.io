+++
title = "链表相关算法"
description = ""
date = 2024-08-14T15:43:27+08:00
image = ""
draft = true
slug = "linkedList"
categories = ['algorithm']
+++

## 链表结构

```java
/**
 * 算法链表结构
 */
public class ListNode {
     public int val;
     public ListNode next;
     ListNode() {}
     public ListNode(int val) { this.val = val; }
     ListNode(int val, ListNode next) { this.val = val; this.next = next; }

    public static ListNode build(Integer... obj){
         return build(Arrays.asList(obj));
    }
    public static ListNode build(List<Integer> arr){
         if(arr.isEmpty()){
             return null;
         }

        ListNode listNode = new ListNode(arr.get(0));
         ListNode cur=listNode;
        for (int i = 1; i < arr.size(); i++) {
            cur.next=new ListNode(arr.get(i));
            cur=cur.next;
        }
        return listNode;
    }
    public void print(){
         ListNode node=this;
         while(node!=null){
             System.out.print(node.val+",");
             node=node.next;
         }
        System.out.println();
    }
 }
```

## 反转链表

<details>
<summary>题目</summary>
给定链表头结点，要求原地反转该链表，返回链表新的头结点。
例：1->2->3，反转后链表应为3->2->1，返回节点3；
</details>

<details>
<summary>思路</summary>
<pre><code>
/**
     * 这种思路的核心在于不需要动head，真正原地移动，但需要构建一个假节点方便返回
     * pre-1-2-3
     * 拿掉2，所以要先获取到2；
     * 1和3建立连接；变为pre-1-3   2-3
     * 2指向pre后面的节点 pre-1-3  2-1-3
     * pre指向2 pre-2-1-3 
     * 全程不需要动head，当head或者head.next为空时，表明最后一个节点也移动到了pre后面
     * 因此返回pre.next
     */
    static ListNode reverse(ListNode head) {
        ListNode pre=new ListNode(-1);
        pre.next=head;
        ListNode next;
        //pre-1-2-3
        while(head!=null&&head.next!=null){
            //next=2
            next=head.next;
            //1-3
            head.next=next.next;
            //2-1
            next.next=pre.next;
            //pre-2
            pre.next=next;
        }
        return pre.next;
    }
    /**
     * 这个解法的思路我称之为接头霸王：核心构建一个新链表，节点为null。即同时存在null 1-2-3，然后一个一个让右边这个链表的头摘下来指向左边的头
     * null 1-2-3
     * 1-null 2-3
     * 2-1-null 3
     * 3-2-1-null null
     * 右边链表头没了之后，要让next作为头，所以还要先获取next
     * 左边链表有了新头之后，要作为pre，给下个头做准备，因此pre=head
     */
    static ListNode reverse2(ListNode head) {
        ListNode pre=null,next=null;
        while(head!=null){
            next=head.next;
            //接头
            head.next=pre;
            //左边链表更新
            pre=head;
            //右边链表更新
            head=next;
        }
        return pre;
    }
</code></pre>
</details>

## 链表环节点
