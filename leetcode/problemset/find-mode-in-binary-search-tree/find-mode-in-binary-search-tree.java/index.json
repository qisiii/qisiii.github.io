{"title":"二叉搜索树中的众数 (Find Mode in Binary Search Tree)","permalink":"https://www.qisihub.cn/leetcode/problemset/find-mode-in-binary-search-tree/find-mode-in-binary-search-tree.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 二叉搜索树中的众数 (Find Mode in Binary Search Tree) // @Author: qisiii // @Date: 2024-09-16 16:19:59 // @Runtime: 0 ms // @Memory: 43.9 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int cur , count = 0, max = 0; List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public int[] findMode(TreeNode root) { dfs(root); int[] arr = new int[result.size()]; for (int i = 0; i \u0026lt; result.size(); i++) { arr[i] = result.get(i); } return arr; } private void dfs(TreeNode root) { if (root == null) { return; } dfs(root.left); if (root.val==cur) { count++; }else { cur = root.val; count = 1; } if (count == max) { result.add(cur); } else if (count \u0026gt; max) { max = count; result.clear(); result.add(cur); } dfs(root.right); } } "}