{"title":"摆动序列 (Wiggle Subsequence)","permalink":"https://www.qisihub.cn/leetcode/problemset/wiggle-subsequence/wiggle-subsequence.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 摆动序列 (Wiggle Subsequence) // @Author: qisiii // @Date: 2024-09-22 16:45:49 // @Runtime: 0 ms // @Memory: 40.3 MB // @comment: // @flag: class Solution { public int wiggleMaxLength(int[] nums) { if (nums.length \u0026lt; 2) { return nums.length; } else if (nums.length == 2) { } int index = 0; int count = 1; Boolean flag = null; for (int i = 1; i \u0026lt; nums.length; i++) { if (i == nums.length - 1) { //之前没有方向，即没有上坡或者下坡，如1,2或者112这种情况 if (flag == null) { //只要不等，就是有坡度 if (nums[i] != nums[index]) { count++; index = i; } } else { //如果之前是峰顶，那么最后一个得是小于峰顶才算 if (flag \u0026amp;\u0026amp; nums[i] \u0026lt; nums[index]) { count++; index = i; //反之亦然 } else if (!flag \u0026amp;\u0026amp; nums[i] \u0026gt; nums[index]) { count++; index = i; } break; } } //当前是峰顶 if (nums[i] \u0026gt; nums[index] \u0026amp;\u0026amp; nums[i] \u0026gt; nums[i + 1]) { index = i; count++; flag = true; //当前是峰底 } else if (nums[i] \u0026lt; nums[index] \u0026amp;\u0026amp; nums[i] \u0026lt; nums[i + 1]) { index = i; count++; flag = false; } } return count; } } +++ title = \u0026ldquo;摆动序列 (Wiggle Subsequence)\u0026rdquo; draft = false +++\n思路:寻找峰顶和峰底 // @Title: 摆动序列 (Wiggle Subsequence) // @Author: qisiii // @Date: 2024-09-22 16:47:16 // @Runtime: 0 ms // @Memory: 40.4 MB // @comment: 寻找峰顶和峰底 // @flag: WHITE class Solution { public int wiggleMaxLength(int[] nums) { if (nums.length \u0026lt; 2) { return nums.length; } //记录前一个峰值的位置 int index = 0; // 第一个永远算作1个 int count = 1; // flag为null表示平坡，为true表示达到峰顶，为false表示峰底 Boolean flag = null; for (int i = 1; i \u0026lt; nums.length; i++) { if (i == nums.length - 1) { // 之前没有方向，即没有上坡或者下坡，如1,2或者1，1，2这种情况 if (flag == null) { // 只要不等，就是有坡度 if (nums[i] != nums[index]) { count++; index = i; } } else { // 如果之前是峰顶，那么最后一个得是小于峰顶才算 if (flag \u0026amp;\u0026amp; nums[i] \u0026lt; nums[index]) { count++; index = i; // 反之亦然 } else if (!flag \u0026amp;\u0026amp; nums[i] \u0026gt; nums[index]) { count++; index = i; } break; } } // 当前是峰顶 if (nums[i] \u0026gt; nums[index] \u0026amp;\u0026amp; nums[i] \u0026gt; nums[i + 1]) { index = i; count++; flag = true; // 当前是峰底 } else if (nums[i] \u0026lt; nums[index] \u0026amp;\u0026amp; nums[i] \u0026lt; nums[i + 1]) { index = i; count++; flag = false; } } return count; } } "}