{"title":"二叉树的层序遍历 (Binary Tree Level Order Traversal)","permalink":"https://www.qisihub.cn/leetcode/problemset/binary-tree-level-order-traversal/binary-tree-level-order-traversal.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 二叉树的层序遍历 (Binary Tree Level Order Traversal) // @Author: qisiii // @Date: 2022-03-02 21:42:37 // @Runtime: 3 ms // @Memory: 41.6 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public static List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { LinkedBlockingQueue queue = new LinkedBlockingQueue(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root==null){ return result; } queue.offer(root); doTree(queue, result); return result; } public static void doTree(Queue\u0026lt;TreeNode\u0026gt; queue, List list) { if (queue==null||queue.isEmpty()){ return; } List\u0026lt;Integer\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; temp = new LinkedBlockingQueue();; while (!queue.isEmpty()) { TreeNode poll = queue.remove(); if (poll==null){ continue; } objects.add(poll.val); if (poll.left!=null){ temp.offer(poll.left); } if (poll.right!=null){ temp.offer(poll.right); } } if (!objects.isEmpty()) { list.add(objects); } doTree(temp, list); } } +++ title = \u0026ldquo;二叉树的层序遍历 (Binary Tree Level Order Traversal)\u0026rdquo; draft = false +++\n思路:bfs，队列层级遍历 // @Title: 二叉树的层序遍历 (Binary Tree Level Order Traversal) // @Author: qisiii // @Date: 2024-01-14 19:25:34 // @Runtime: 1 ms // @Memory: 43.7 MB // @comment: bfs，队列层级遍历 // @flag: WHITE /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result= new ArrayList(); if(root==null){ return result; } result.add(new ArrayList(Arrays.asList(root.val))); List\u0026lt;TreeNode\u0026gt; rootList=new ArrayList(); rootList.add(root); bfs(rootList,result); return result; } void bfs(List\u0026lt;TreeNode\u0026gt; queue,List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result){ if (queue == null||queue.size()\u0026lt;=0){ return; } List\u0026lt;TreeNode\u0026gt; temp=new ArrayList(); List\u0026lt;Integer\u0026gt; level=new ArrayList(); for(int i=0;i\u0026lt;queue.size();i++){ TreeNode node=queue.get(i); if(node.left!=null){ temp.add(node.left); level.add(node.left.val); } if(node.right!=null){ temp.add(node.right); level.add(node.right.val); } } if(level.size()\u0026gt;0){ result.add(level); } bfs(temp,result); } } 思路: // @Title: 二叉树的层序遍历 (Binary Tree Level Order Traversal) // @Author: qisiii // @Date: 2024-09-14 23:21:15 // @Runtime: 1 ms // @Memory: 43.9 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { List\u0026lt;Integer\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int size = queue.size(); while (size \u0026gt; 0) { TreeNode node = queue.poll(); temp.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } size--; } result.add(temp); } return result; } } "}