{"title":"[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)","permalink":"https://www.qisihub.cn/leetcode/problemset/lru-cache/readme/","date":"0001-01-01T00:00:00Z","content":"| English | 简体中文 |\n146. LRU 缓存 题目描述 请你设计并实现一个满足\u0026nbsp; LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量\u0026nbsp;capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value)\u0026nbsp;如果关键字\u0026nbsp;key 已经存在，则变更其数据值\u0026nbsp;value ；如果不存在，则向缓存中插入该组\u0026nbsp;key-value 。如果插入操作导致关键字数量超过\u0026nbsp;capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\u0026nbsp;\n示例：\n输入 [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // 缓存是 {1=1} lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} lRUCache.get(1); // 返回 1 lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} lRUCache.get(2); // 返回 -1 (未找到) lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} lRUCache.get(1); // 返回 -1 (未找到) lRUCache.get(3); // 返回 3 lRUCache.get(4); // 返回 4 \u0026nbsp;\n提示：\n1 \u0026lt;= capacity \u0026lt;= 3000 0 \u0026lt;= key \u0026lt;= 10000 0 \u0026lt;= value \u0026lt;= 105 最多调用 2 * 105 次 get 和 put 相关话题 设计 哈希表 链表 双向链表 相似题目 LFU 缓存 设计内存文件系统 迭代压缩字符串 None 设计最近使用（MRU）队列 "}