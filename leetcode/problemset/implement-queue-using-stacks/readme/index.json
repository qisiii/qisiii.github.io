{"title":"[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)","permalink":"https://www.qisihub.cn/leetcode/problemset/implement-queue-using-stacks/readme/","date":"0001-01-01T00:00:00Z","content":"| English | 简体中文 |\n232. 用栈实现队列 题目描述 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\nvoid push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：\n你 只能 使用标准的栈操作 —— 也就是只有\u0026nbsp;push to top,\u0026nbsp;peek/pop from top,\u0026nbsp;size, 和\u0026nbsp;is empty\u0026nbsp;操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 \u0026nbsp;\n示例 1：\n输入： [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false \u0026nbsp;\n提示：\n1 \u0026lt;= x \u0026lt;= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） \u0026nbsp;\n进阶：\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 相关话题 栈 设计 队列 相似题目 用队列实现栈 "}