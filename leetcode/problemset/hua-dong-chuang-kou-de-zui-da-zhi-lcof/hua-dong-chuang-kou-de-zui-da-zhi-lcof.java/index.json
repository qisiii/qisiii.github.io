{"title":"望远镜中最高的海拔 (望远镜中最高的海拔)","permalink":"https://www.qisihub.cn/leetcode/problemset/hua-dong-chuang-kou-de-zui-da-zhi-lcof/hua-dong-chuang-kou-de-zui-da-zhi-lcof.java/","date":"0001-01-01T00:00:00Z","content":"思路:使用双向队列 // @Title: 望远镜中最高的海拔 (望远镜中最高的海拔) // @Author: qisiii // @Date: 2022-03-04 14:37:47 // @Runtime: 14 ms // @Memory: 50.6 MB // @comment: 使用双向队列 // @flag: BLUE class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if(nums.length\u0026lt;1||k\u0026lt;=0){ return new int[0]; } Deque\u0026lt;Integer\u0026gt; deque=new LinkedList(); int[] result=new int[nums.length-k+1]; int index=0; //先获取第一个窗口的最大值队列 for (int i = 0; i \u0026lt; k; i++) { //当新值大于队尾的时候，弹出队尾 while(!deque.isEmpty()\u0026amp;\u0026amp;nums[i]\u0026gt;nums[deque.peekLast()]){ deque.pollLast(); } deque.offer(i); } result[index]=nums[deque.peekFirst()]; for (int i = k; i \u0026lt; nums.length; i++) { //当队首不在窗口内时，出队 if(deque.peekFirst()\u0026lt;=i-k){ deque.pollFirst(); } //当新值大于队尾的时候，弹出队尾 while (!deque.isEmpty()\u0026amp;\u0026amp;nums[i]\u0026gt;nums[deque.peekLast()]){ deque.pollLast(); } deque.offer(i); result[++index]=nums[deque.peekFirst()]; } return result; } } "}