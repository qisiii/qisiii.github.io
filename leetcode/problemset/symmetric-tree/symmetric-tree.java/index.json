{"title":"对称二叉树 (Symmetric Tree)","permalink":"https://www.qisihub.cn/leetcode/problemset/symmetric-tree/symmetric-tree.java/","date":"0001-01-01T00:00:00Z","content":"思路:这算什么广度优先搜索？？？ // @Title: 对称二叉树 (Symmetric Tree) // @Author: qisiii // @Date: 2024-01-14 18:55:34 // @Runtime: 0 ms // @Memory: 40.6 MB // @comment: 这算什么广度优先搜索？？？ // @flag: WHITE /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if(root==null){ return true; } return isEquals(root.left,root.right); } public boolean isEquals(TreeNode left,TreeNode right){ if(left==null||right==null){ return left==right; } return left.val==right.val\u0026amp;\u0026amp;isEquals(left.left,right.right)\u0026amp;\u0026amp;isEquals(left.right,right.left); } } 思路: // @Title: 对称二叉树 (Symmetric Tree) // @Author: qisiii // @Date: 2024-09-15 00:28:15 // @Runtime: 0 ms // @Memory: 40.7 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { return isEquals(root.left,root.right); } private boolean isEquals(TreeNode left,TreeNode right){ if(left==null||right==null){ return left==right; } return left.val==right.val\u0026amp;\u0026amp;isEquals(left.left,right.right)\u0026amp;\u0026amp;isEquals(left.right,right.left); } } 思路: // @Title: 对称二叉树 (Symmetric Tree) // @Author: qisiii // @Date: 2022-03-01 22:29:23 // @Runtime: 0 ms // @Memory: 39.5 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if(root==null)return true; return isJing(root.left,root.right); } public boolean isJing(TreeNode left,TreeNode right){ if(left==null\u0026amp;\u0026amp;right==null){ return true; } if(left==null||right==null){ return false; } return left.val==right.val\u0026amp;\u0026amp;isJing(left.left,right.right)\u0026amp;\u0026amp;isJing(left.right,right.left); } } "}