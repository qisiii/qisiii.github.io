{"title":"从前序与中序遍历序列构造二叉树 (Construct Binary Tree from Preorder and Inorder Traversal)","permalink":"https://www.qisihub.cn/leetcode/problemset/construct-binary-tree-from-preorder-and-inorder-traversal/construct-binary-tree-from-preorder-and-inorder-traversal.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 从前序与中序遍历序列构造二叉树 (Construct Binary Tree from Preorder and Inorder Traversal) // @Author: qisiii // @Date: 2024-09-15 17:56:05 // @Runtime: 8 ms // @Memory: 83.3 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if(preorder.length==0){ return null; } TreeNode root = new TreeNode(preorder[0]); if (preorder.length == 1) { return root; } int index = findIndex(inorder, root.val); root.left = buildTree(Arrays.copyOfRange(preorder, 1, index + 1), Arrays.copyOfRange(inorder, 0, index)); root.right = buildTree(Arrays.copyOfRange(preorder, index + 1, preorder.length), Arrays.copyOfRange(inorder, index+1, inorder.length)); return root; } private int findIndex(int[] inorder, int target) { for (int i = 0; i \u0026lt; inorder.length; i++) { if (inorder[i] == target) { return i; } } return -1; } } "}