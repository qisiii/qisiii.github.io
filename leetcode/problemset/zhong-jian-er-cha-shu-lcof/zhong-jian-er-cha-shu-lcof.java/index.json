{"title":"推理二叉树 (推理二叉树)","permalink":"https://www.qisihub.cn/leetcode/problemset/zhong-jian-er-cha-shu-lcof/zhong-jian-er-cha-shu-lcof.java/","date":"0001-01-01T00:00:00Z","content":"思路:节省空间 // @Title: 推理二叉树 (推理二叉树) // @Author: qisiii // @Date: 2022-02-19 19:08:33 // @Runtime: 15 ms // @Memory: 82.1 MB // @comment: 节省空间 // @flag: ORANGE /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length\u0026lt;=0){ return null; } int index=0; TreeNode root = new TreeNode(preorder[0]); for (int i = 0; i \u0026lt; inorder.length\u0026amp;\u0026amp;inorder.length\u0026gt;1; i++) { if (inorder[i]==Integer.valueOf(root.val)) { index=i;break; } } root.left = buildTree(Arrays.copyOfRange(preorder,1,index+1),Arrays.copyOfRange(inorder,0,index)); root.right = buildTree(Arrays.copyOfRange(preorder,index+1,preorder.length),Arrays.copyOfRange(inorder,index+1,inorder.length)); return root; } } +++ title = \u0026ldquo;推理二叉树 (推理二叉树)\u0026rdquo; draft = false +++\n思路: // @Title: 推理二叉树 (推理二叉树) // @Author: qisiii // @Date: 2022-02-19 18:33:49 // @Runtime: 9 ms // @Memory: 85.8 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { int n = preorder.length; if (n == 0) return null; int rootVal = preorder[0], rootIndex = 0; for (int i = 0; i \u0026lt; n; i++) { if (inorder[i] == rootVal) { rootIndex = i; break; } } TreeNode root = new TreeNode(rootVal); root.left = buildTree(Arrays.copyOfRange(preorder, 1, 1 + rootIndex), Arrays.copyOfRange(inorder, 0, rootIndex)); root.right = buildTree(Arrays.copyOfRange(preorder, 1 + rootIndex, n), Arrays.copyOfRange(inorder, rootIndex + 1, n)); return root; } } 思路:通过递归 // @Title: 推理二叉树 (推理二叉树) // @Author: qisiii // @Date: 2022-02-19 19:01:43 // @Runtime: 81 ms // @Memory: 41.4 MB // @comment: 通过递归 // @flag: BLUE /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length\u0026lt;=0){ return null; } List\u0026lt;Integer\u0026gt; pre=new ArrayList\u0026lt;\u0026gt;(); for (int i : preorder) { pre.add(i); } List\u0026lt;Integer\u0026gt; in=new ArrayList\u0026lt;\u0026gt;(); for (int i : inorder) { in.add(i); } return build(pre,in); } public static TreeNode build(List pre, List in) { if (pre.size()\u0026lt;=0){ return null; } TreeNode root = new TreeNode((Integer) pre.get(0)); for (int i = 0; i \u0026lt; in.size()\u0026amp;\u0026amp;in.size()\u0026gt;1; i++) { if (in.get(i).equals(Integer.valueOf(root.val))) { root.left = build(pre.subList(1, 1 + i), in.subList(0, i)); root.right = build(pre.subList(1 + i, pre.size()), in.subList(i + 1, in.size())); } } return root; } } "}