{"title":"二叉树的后序遍历 (Binary Tree Postorder Traversal)","permalink":"https://www.qisihub.cn/leetcode/problemset/binary-tree-postorder-traversal/binary-tree-postorder-traversal.java/","date":"0001-01-01T00:00:00Z","content":"思路:递归 // @Title: 二叉树的后序遍历 (Binary Tree Postorder Traversal) // @Author: qisiii // @Date: 2024-09-14 21:05:17 // @Runtime: 0 ms // @Memory: 40.7 MB // @comment: 递归 // @flag: GREEN /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result=new ArrayList\u0026lt;\u0026gt;(); sort(result,root); return result; } private void sort(List\u0026lt;Integer\u0026gt; result,TreeNode node){ if(node!=null){ sort(result,node.left); sort(result,node.right); result.add(node.val); } } } +++ title = \u0026ldquo;二叉树的后序遍历 (Binary Tree Postorder Traversal)\u0026rdquo; draft = false +++\n思路:迭代 // @Title: 二叉树的后序遍历 (Binary Tree Postorder Traversal) // @Author: qisiii // @Date: 2024-09-14 22:35:50 // @Runtime: 1 ms // @Memory: 40.8 MB // @comment: 迭代 // @flag: GREEN /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); HashSet\u0026lt;TreeNode\u0026gt; parent = new HashSet\u0026lt;\u0026gt;(); while (root != null || !stack.isEmpty()) { if (root == null \u0026amp;\u0026amp; parent.contains(stack.peek())) { //当左子树和右子树都处理完了 result.add(stack.pop().val); } else if (root == null) { parent.add(stack.peek()); //然后处理右子树 root = stack.peek().right; } else { //先将左边的节点都放到队列 stack.push(root); root = root.left; } } return result; } } "}