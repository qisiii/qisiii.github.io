{"title":"用队列实现栈 (Implement Stack using Queues)","permalink":"https://www.qisihub.cn/leetcode/problemset/implement-stack-using-queues/implement-stack-using-queues.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 用队列实现栈 (Implement Stack using Queues) // @Author: qisiii // @Date: 2022-02-28 18:29:10 // @Runtime: 0 ms // @Memory: 38.9 MB // @comment: // @flag: class MyStack { private Queue\u0026lt;Integer\u0026gt; push=new LinkedList(); private Queue\u0026lt;Integer\u0026gt; pop=new LinkedList(); public MyStack() { } public void push(int x) { pop.offer(Integer.valueOf(x)); while(!push.isEmpty()){ Integer v= push.poll(); pop.offer(v); } Queue\u0026lt;Integer\u0026gt; temp=push; push=pop; pop=temp; } public int pop() { return push.poll(); } public int top() { return push.peek(); } public boolean empty() { return push.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ +++ title = \u0026ldquo;用队列实现栈 (Implement Stack using Queues)\u0026rdquo; draft = false +++\n思路: // @Title: 用队列实现栈 (Implement Stack using Queues) // @Author: qisiii // @Date: 2024-09-14 11:48:07 // @Runtime: 0 ms // @Memory: 40.4 MB // @comment: // @flag: class MyStack { private Queue\u0026lt;Integer\u0026gt; popQueue=new LinkedList\u0026lt;\u0026gt;(); private Queue\u0026lt;Integer\u0026gt; tempQueue=new LinkedList\u0026lt;\u0026gt;(); public MyStack() { } public void push(int x) { tempQueue.offer(x); while (!popQueue.isEmpty()){ tempQueue.offer(popQueue.poll()); } while (!tempQueue.isEmpty()){ popQueue.offer(tempQueue.poll()); } } public int pop() { return popQueue.poll(); } public int top() { return popQueue.peek(); } public boolean empty() { return popQueue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ 思路: // @Title: 用队列实现栈 (Implement Stack using Queues) // @Author: qisiii // @Date: 2024-08-13 15:35:27 // @Runtime: 0 ms // @Memory: 40.3 MB // @comment: // @flag: class MyStack { Queue\u0026lt;Integer\u0026gt; push=new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; pop=new LinkedList(); public MyStack() { } public void push(int x) { push.add(x); while (!pop.isEmpty()){ push.add(pop.poll()); } Queue temp=new ArrayDeque(); temp=pop; pop=push; push=temp; } public int pop() { return pop.poll(); } public int top() { return pop.peek(); } public boolean empty() { return pop.isEmpty(); } } 思路:将数据保持成栈的顺序稳定在一个队列里 // @Title: 用队列实现栈 (Implement Stack using Queues) // @Author: qisiii // @Date: 2024-01-02 21:44:53 // @Runtime: 0 ms // @Memory: 40.2 MB // @comment: 将数据保持成栈的顺序稳定在一个队列里 // @flag: ORANGE class MyStack { Queue\u0026lt;Integer\u0026gt; push=new ArrayDeque(); Queue\u0026lt;Integer\u0026gt; pop=new ArrayDeque(); public MyStack() { } public void push(int x) { pop.add(x); while (!push.isEmpty()){ pop.add(push.poll()); } Queue temp=new ArrayDeque(); temp=pop; pop=push; push=temp; } public int pop() { return push.poll(); } public int top() { return push.peek(); } public boolean empty() { return push.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ "}