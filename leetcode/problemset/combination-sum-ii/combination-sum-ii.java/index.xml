<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>组合总和 II (Combination Sum II) on 起司的主页</title><link>https://www.qisihub.cn/leetcode/problemset/combination-sum-ii/combination-sum-ii.java/</link><description>Recent content in 组合总和 II (Combination Sum II) on 起司的主页</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>起司</copyright><atom:link href="https://www.qisihub.cn/leetcode/problemset/combination-sum-ii/combination-sum-ii.java/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary</title><link>https://www.qisihub.cn/post/base/binary/</link><pubDate>Sat, 12 Oct 2024 20:48:12 +0800</pubDate><guid>https://www.qisihub.cn/post/base/binary/</guid><description>原码、反码和补码 这里不展开讲了，只是做个结论记录，网上文章多的是 正数的补码是其原码本身 负数的补码是其原码除符号位取反之后+1， 负数通过补码计</description></item><item><title>Raft算法理论学习(一)</title><link>https://www.qisihub.cn/post/tech/distributed/raft/theory/</link><pubDate>Mon, 30 Sep 2024 10:54:07 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/raft/theory/</guid><description>&lt;img src="http://picgo-cloudflare.qisihub.cn/post/2024/11/ffef51adc51af216dd8ff2e16ebac9d3.png" alt="Featured image of post Raft算法理论学习(一)" />随着接触各种开源的中间件或者数据库，总是会了解到他们必须保证多节点的一致性。比如Zookeeper使用了Zab来保证CP；Nacos既支持A</description></item><item><title>AcceptEpoch和CurrentEpoch区别</title><link>https://www.qisihub.cn/post/tech/distributed/zookeeper/diff_acceptepoch_currentepoch/</link><pubDate>Sat, 28 Sep 2024 15:30:04 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/zookeeper/diff_acceptepoch_currentepoch/</guid><description>最近在看Raft算法，在看到一些文档说Zab和Raft区别时总觉得我看源码了解到的不同，但也不知道是不是版本的问题。保险起见，我去读了一下Z</description></item><item><title>ThreadPoolExecutor分析</title><link>https://www.qisihub.cn/post/tech/lang/threadpoolexecutor/</link><pubDate>Tue, 24 Sep 2024 23:19:39 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/lang/threadpoolexecutor/</guid><description>本文记录一下ThreadPollExecutor如何管理线程和任务，何时创建线程？何时销毁线程？ threadPoolExecutor提交任务</description></item><item><title>Zookeeper源码分析-Zab协议</title><link>https://www.qisihub.cn/post/tech/distributed/zookeeper/zab/</link><pubDate>Wed, 14 Aug 2024 15:08:39 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/zookeeper/zab/</guid><description>基本概念 建议读一下20 共识算法：一次性说清楚 Paxos、Raft 等算法的区别，里面讲的还算易懂。 ZAB是zookeeper专门为了保持分布式</description></item><item><title>Hugo&amp;Stack主题的使用和装修记录</title><link>https://www.qisihub.cn/post/site/hugo_stack_record/</link><pubDate>Sat, 10 Aug 2024 16:32:55 +0800</pubDate><guid>https://www.qisihub.cn/post/site/hugo_stack_record/</guid><description>hugo官网|Stack官网 stack自带小部件： Widgets | Stack widgets: homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 在stack的配置文件中，搜索工具、归</description></item><item><title>Zookeeper源码分析-选举机制</title><link>https://www.qisihub.cn/post/tech/distributed/zookeeper/election/</link><pubDate>Fri, 09 Aug 2024 18:01:30 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/zookeeper/election/</guid><description>部署 在单机上部署伪集群，需要根据不同的配置文件启动不同的进程。 #这是zoo1.cfg的内容 tickTime=2000 initLimit=10 syncLimit=5 dataDir=/opt/soft/zookeeper/data/1 clientPort=2181 #第一个端口号用于zk集群同步数据，第二</description></item><item><title>Zookeeper源码分析-watch机制</title><link>https://www.qisihub.cn/post/tech/distributed/zookeeper/watch/</link><pubDate>Thu, 08 Aug 2024 23:34:10 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/zookeeper/watch/</guid><description>Zookeeper框架设计了一种叫做watch的机制，客户端可以给某个节点添加watcher，当节点改变的时候，服务端会推送一个消息到客户端</description></item><item><title>Zookeeper源码学习-单机部分通信组件</title><link>https://www.qisihub.cn/post/tech/distributed/zookeeper/zookeeperservermain/</link><pubDate>Mon, 05 Aug 2024 12:59:08 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/zookeeper/zookeeperservermain/</guid><description>调试前准备 对于大部分的开源项目，一般都可以从其启动shell脚本中分析出来java启动类。我这里clone源码后以tag 3.9.1为主创建了</description></item><item><title>单服务器Redis集群部署记录</title><link>https://www.qisihub.cn/post/tech/distributed/redis_cluster_deploy/</link><pubDate>Tue, 30 Jul 2024 23:27:58 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/redis_cluster_deploy/</guid><description>部署 参考Redis 集群教程使用单云服务器启动多个节点来当做redis集群，这里使用7000-7005这6个节点，三主三从 #准备好文件夹 mkdir redis-cluster cd</description></item><item><title>Jstack使用</title><link>https://www.qisihub.cn/post/tech/lang/jstack/</link><pubDate>Sun, 28 Jul 2024 17:14:47 +0800</pubDate><guid>https://www.qisihub.cn/post/tech/lang/jstack/</guid><description>Jstack应用 jstack是java提供的工具，一般用于分析栈-线程相关的问题，常见的比如死锁问题，cpu过高问题。 jstack 命令使用方式如下： jstack</description></item><item><title>搭建自己的博客</title><link>https://www.qisihub.cn/post/site/personsite/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/site/personsite/</guid><description>建站方式 选择建站方式，是使用动态建站（如WordPress、halo），还是使用静态建站（Jekyll、hexo、hugo）。 前者更偏向于传</description></item><item><title>SpringBean循环依赖处理流程</title><link>https://www.qisihub.cn/post/tech/spring/cycle_bean/</link><pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/spring/cycle_bean/</guid><description>@Service public class Bean1 { @Autowired private Bean2 bean2; // @Async public void test(){ System.out.println(&amp;#34;Bean1&amp;#34;); } } @Service public class Bean2 { @Autowired private Bean1 bean1; // @Async public void test(){ System.out.println(&amp;#34;Bean2&amp;#34;); } } 在doGetBean的第一个节点上，会调用到getSingleon这个方</description></item><item><title>RefershScope源码分析</title><link>https://www.qisihub.cn/post/tech/spring/refershscope/</link><pubDate>Sun, 26 May 2024 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/spring/refershscope/</guid><description>Spring中是存在多个Scope的，比如大部分的bean都是单例(Singleton)，还有一些不常用的比如原型(Prototype)、r</description></item><item><title>Aop执行逻辑</title><link>https://www.qisihub.cn/post/tech/spring/aop/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/spring/aop/</guid><description>AopAutoConfiguration 在spring-boot-autoconfiguration的spring.factories中指定了org.springframewor</description></item><item><title>Dubbo的SPI增强</title><link>https://www.qisihub.cn/post/tech/distributed/dubbo/dubbo_spi/</link><pubDate>Sun, 17 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/dubbo/dubbo_spi/</guid><description>自定义扩展 Jdk的SPI缺点在于需要遍历所有的扩展类并实例化，dubbo对此做了优化。 使其支持按需实例化，其本质是将所有的扩展类Class存</description></item><item><title>Guava的RateLimiter</title><link>https://www.qisihub.cn/post/tech/tool/guava_ratelimiter/</link><pubDate>Sat, 06 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/tool/guava_ratelimiter/</guid><description>单机的限流工具 使用 //普通的限流，不支持预热，使用的是SmoothBursty RateLimiter rateLimiter=RateLimiter.create(10); //获取令牌的时间 double acquire = rateLimiter.acquire(); //能否获取令牌 boolean b = rateLimiter.tryAcquire(); //支持</description></item><item><title>UndoLog和redoLog</title><link>https://www.qisihub.cn/post/tech/mysql/undolog_redolog/</link><pubDate>Sat, 30 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/mysql/undolog_redolog/</guid><description>redolog 从ACID了解到，对于数据库来说，原子性和持久性是为了保证数据修改之后就不会再有变换，但是持久性这个动作不是一个原子性的操作，包含写入、未</description></item><item><title>@Async源码分析</title><link>https://www.qisihub.cn/post/tech/spring/async/</link><pubDate>Tue, 26 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/spring/async/</guid><description>@EnableAsync @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(AsyncConfigurationSelector.class) public @interface EnableAsync { //这里应该是可以自定义注解 Class&amp;lt;? extends Annotation&amp;gt; annotation() default Annotation.class; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE; 由Spring注册BeanDefinition的方式 可知，</description></item><item><title>Spring注册BeanDefinition的方式</title><link>https://www.qisihub.cn/post/tech/spring/beandefinitionregistion/</link><pubDate>Mon, 25 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/spring/beandefinitionregistion/</guid><description>通过在org.springframework.beans.factory.support.DefaultListableBeanFactor</description></item><item><title>偷偷开启的监控在吃内存</title><link>https://www.qisihub.cn/post/tech/problem/springactuator_fullgc/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/problem/springactuator_fullgc/</guid><description>整体复盘： 一个不算普通的周五中午，同事收到了大量了cpu异常的报警。根据报警表现和通过arthas查看，很明显的问题就是内存不足，疯狂无效g</description></item><item><title>Java安全机制之一——SecurityManager和AccessController</title><link>https://www.qisihub.cn/post/tech/lang/java_security/</link><pubDate>Wed, 08 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/lang/java_security/</guid><description>前言： 在看socket相关代码的时候，AbstractPlainSocketImpl中的一段代码吸引了我，其实之前见过很多次类似的代码，但一</description></item><item><title>JavaAgent技术</title><link>https://www.qisihub.cn/post/tech/lang/javaagent/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/lang/javaagent/</guid><description>在定位公司问题的时候，需要了解一下skywalking的相关知识，而agent就提上了日程。 官网文档 Agent技术是Jdk在1.5版本之后，</description></item><item><title>分析Skywalking的controller加强原理</title><link>https://www.qisihub.cn/post/tech/distributed/skywalking/skywalkingcontroller/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/skywalking/skywalkingcontroller/</guid><description>在阅读本篇文章之前，建议先了解agent的启动流程，这对分析controller加强原理有很大的帮助，Skywalking Agent启动流程</description></item><item><title>SkywalkingAgent启动流程源码分析</title><link>https://www.qisihub.cn/post/tech/distributed/skywalking/skywalkingagent/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/distributed/skywalking/skywalkingagent/</guid><description>Skywalking 从架构上分为三个大模块，分别是Agent、Oap（Backend&amp;amp;Storage）、UI。这篇文档主要是介绍Agent部分。这部分</description></item><item><title>记一次内存飙升、gc频繁、cpu飙高</title><link>https://www.qisihub.cn/post/tech/problem/task_fullgc/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/problem/task_fullgc/</guid><description>紧急排查： 一个普通工作日的晚上8点，突然收到大量接口超时的报警，最高甚至有超100s，于是开始紧急排查。 首先是看监控面板里的内存监控和cpu</description></item><item><title>线程异常增长</title><link>https://www.qisihub.cn/post/tech/problem/thread_exception/</link><pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/problem/thread_exception/</guid><description>小组群内leader甩出来一个截图，说是线程有些异常，一直在增长，从pool-1-thread一直到pool-285-thread，每个po</description></item><item><title>IDEA进程远程Debug</title><link>https://www.qisihub.cn/post/tech/tool/remote_debug/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/tool/remote_debug/</guid><description>普通的应用启动 新建一个Remote_JVM_Debug配置 填入自己的服务器的ip和任意一个没有被占用的端口号（非当前应用启动用的端口号），然</description></item><item><title>锁</title><link>https://www.qisihub.cn/post/tech/mysql/db_lock/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/mysql/db_lock/</guid><description>MVCC机制遗留的问题 为什么在可重复读级别下，幻读没有产生？ 回想一下在事务隔离级别那篇文章中，可串行化是通过什么保证的？ 对操作的每一行记录加</description></item><item><title>MVCC机制</title><link>https://www.qisihub.cn/post/tech/mysql/mvcc/</link><pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/mysql/mvcc/</guid><description>&lt;img src="https://www.qisihub.cn/blog-img/mvcc.png" alt="Featured image of post MVCC机制" />事务隔离级别遗留问题： 在读已提交的级别下，事务B可以读到事务A持有写锁的的记录，且读到的是未更新前的，为何写读没有冲突？ 可重复读级别，事务B</description></item><item><title>事务隔离级别</title><link>https://www.qisihub.cn/post/tech/mysql/transaction_isolation/</link><pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/mysql/transaction_isolation/</guid><description>标准隔离级别 读未提交、读已提交、可重复读、串行化 串行化 对事务中所有读写的数据加上读锁、写锁、范围锁。所以冲突的事务必须同步执行。 //console1 start transaction ; select *</description></item><item><title>Java的SPI机制</title><link>https://www.qisihub.cn/post/tech/lang/java_spi/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/lang/java_spi/</guid><description>本质是将接口和实现进行解耦，使得外部程序可以提供不同的实现； 实现机制为ServiceLoader通过迭代器进行 public Iterator&amp;lt;S&amp;gt; iterator() { return new Iterator&amp;lt;S&amp;gt;() { //之所以有k</description></item><item><title>回溯</title><link>https://www.qisihub.cn/post/algorithm/back/</link><pubDate>Wed, 21 Sep 2022 20:37:59 +0800</pubDate><guid>https://www.qisihub.cn/post/algorithm/back/</guid><description>回溯其实大部分都是采用递归的写法，通过dfs尝试所有的可能性，获取自己想要的结果；本质上可以构造成一棵树，构造节点时如果条件不符合则意味着可</description></item><item><title>树</title><link>https://www.qisihub.cn/post/algorithm/tree/</link><pubDate>Wed, 14 Sep 2022 21:09:08 +0800</pubDate><guid>https://www.qisihub.cn/post/algorithm/tree/</guid><description>遍历 递归 public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; result=new ArrayList&amp;lt;&amp;gt;(); sort(result,root); return result; } private void sort(List&amp;lt;Integer&amp;gt; result,TreeNode node){ if(node!=null){ result.add(node.val); sort(result,node.left); sort(result,node.right); } } 迭代 不同于遍历的规整，三种顺序的迭代逻辑各不相同。 /** * 迭代-前序 * 中-左-右 借用栈来压</description></item><item><title>栈和队列</title><link>https://www.qisihub.cn/post/algorithm/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link><pubDate>Tue, 13 Sep 2022 23:10:22 +0800</pubDate><guid>https://www.qisihub.cn/post/algorithm/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid><description>用栈实现队列 232. 用栈实现队列 仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 思路：</description></item><item><title>其他算法</title><link>https://www.qisihub.cn/post/algorithm/other/</link><pubDate>Mon, 12 Sep 2022 20:07:49 +0800</pubDate><guid>https://www.qisihub.cn/post/algorithm/other/</guid><description>哈希表 快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复</description></item><item><title>数组</title><link>https://www.qisihub.cn/post/algorithm/array/</link><pubDate>Tue, 06 Sep 2022 16:32:12 +0800</pubDate><guid>https://www.qisihub.cn/post/algorithm/array/</guid><description>排序 快排 核心思想是选定一个阈值temp 通过左右指针，将比temp小的放左边，比temp大的放右边。 对两个子序列重复排序。 public static void quickSort(int[] nums){ doQuickSort(nums,0,nums.length-1); } public static void</description></item><item><title>链表</title><link>https://www.qisihub.cn/post/algorithm/linkedlist/</link><pubDate>Sun, 14 Aug 2022 15:43:27 +0800</pubDate><guid>https://www.qisihub.cn/post/algorithm/linkedlist/</guid><description>链表结构 /** * 算法链表结构 */ public class ListNode { public int val; public ListNode next; ListNode() {} public ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } public static ListNode build(Integer... obj){ return build(Arrays.asList(obj)); } public static ListNode build(List&amp;lt;Integer&amp;gt; arr){ if(arr.isEmpty()){ return null; } ListNode listNode = new ListNode(arr.get(0)); ListNode cur=listNode; for</description></item><item><title>Java集合源码分析</title><link>https://www.qisihub.cn/post/tech/lang/javacollection/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/lang/javacollection/</guid><description>hashmap源码分析 构造函数 initialCapacity 初始化大小，一般最好2次幂 public HashMap(int initialCapacity, float loadFactor) { //初始化值默认是16 if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&amp;#34;Illegal initial capacity: &amp;#34; + initialCapacity); if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &amp;lt;= 0 ||</description></item><item><title>JavaLock类源码分析</title><link>https://www.qisihub.cn/post/tech/lang/javalock/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/lang/javalock/</guid><description>Lock和Condition接口 Lock是java中显示使用锁的方案，相比于synchronized，要更加灵活； synchronized在</description></item><item><title/><link>https://www.qisihub.cn/post/tech/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.qisihub.cn/post/tech/</guid><description/></item></channel></rss>