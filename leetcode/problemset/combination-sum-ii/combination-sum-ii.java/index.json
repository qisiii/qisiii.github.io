{"title":"组合总和 II (Combination Sum II)","permalink":"https://www.qisihub.cn/leetcode/problemset/combination-sum-ii/combination-sum-ii.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 组合总和 II (Combination Sum II) // @Author: qisiii // @Date: 2024-04-26 14:18:41 // @Runtime: 867 ms // @Memory: 44.4 MB // @comment: // @flag: import java.util.*; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); return doSolution(candidates, 0, candidates.length - 1, target); } private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; doSolution(int[] candidates, int left, int right, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; set=new HashSet\u0026lt;\u0026gt;(); while (left \u0026lt;= right) { if(set.contains(candidates[right])){ right--;continue; } if (candidates[right] == target) { set.add(candidates[right]); result.add(new ArrayList\u0026lt;\u0026gt;(Arrays.asList(candidates[right]))); } else if (candidates[right] \u0026lt; target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; temp = doSolution(candidates, left, right-1, target - candidates[right]); for(int i=0;i\u0026lt;temp.size();i++){ set.add(candidates[right]); temp.get(i).add(candidates[right]); } result.addAll(temp); } right--; } return result; } } 思路: // @Title: 组合总和 II (Combination Sum II) // @Author: qisiii // @Date: 2024-09-19 22:53:21 // @Runtime: 3 ms // @Memory: 43.6 MB // @comment: // @flag: class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); dfs(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target,0); return result; } private void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; list, int[] candidates, int target,int index) { if (target == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(list)); return; } //注意，i从index开始是为了避免重复; //以[2,3,6,7]为例,[2,2,3],[2,3,2],[3,2,2]其实都是相同的结果, //2,2,3表示的是选择第一个，第一个，第二个，表示为(112),当固定前两种选择的时候，该字数会尝试所有可能的情况,比如111,113,114；因此当第二个数字为3时，可理解为12x，由于已经尝试过112，因此无需再尝试比当前位靠前的情况 //必须有一个结构可以记录当前层级所有的情况，且不会透传到下层 HashSet\u0026lt;Integer\u0026gt; set=new HashSet\u0026lt;\u0026gt;(); for (int i = index; i \u0026lt; candidates.length; i++) { int temp = candidates[i]; // 由于已经排序，当该元素大于target，则后续值都没有比较的意义了 if (temp \u0026gt; target) { return; } if(set.contains(temp)){ continue; }else{ set.add(temp); } list.add(temp); dfs(result, list, candidates, target - temp,i+1); list.remove(list.size() - 1); } } } "}