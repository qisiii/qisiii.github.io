{"title":"搜索插入位置 (Search Insert Position)","permalink":"https://www.qisihub.cn/leetcode/problemset/search-insert-position/search-insert-position.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 搜索插入位置 (Search Insert Position) // @Author: qisiii // @Date: 2024-04-25 23:54:27 // @Runtime: 0 ms // @Memory: 41.9 MB // @comment: // @flag: class Solution { public int searchInsert(int[] nums, int target) { int left=0,right=nums.length-1; while(left\u0026lt;=right){ int mid=left+(right-left)/2; if(nums[mid]==target){ return mid; }else if(nums[mid]\u0026gt;target){ right=mid-1; }else{ left=mid+1; } } return left; } } +++ title = \u0026ldquo;搜索插入位置 (Search Insert Position)\u0026rdquo; draft = false +++\n思路: // @Title: 搜索插入位置 (Search Insert Position) // @Author: qisiii // @Date: 2024-09-06 16:30:00 // @Runtime: 0 ms // @Memory: 42.1 MB // @comment: // @flag: class Solution { public int searchInsert(int[] nums, int target) { int left=0,right=nums.length-1; while(left\u0026lt;=right){ int mid=left+(right-left)/2; if(nums[mid]==target){ return mid; }else if(nums[mid]\u0026gt;target){ right=mid-1; }else{ left=mid+1; } } //这里需要思考一下 //当进入到最后一次循环的时候，由于left=right，那么mid=left=right； //所以对于if的三种情况，第一种相等就直接返回下标. //后两种，从left角度分析，如果nums[left]\u0026gt;target,那么left正好是要被插入的位置；如果nums[left]\u0026lt;target，那么要插入的位置就是下一个，即left+1，刚好在else中的逻辑就是这样，因此，最后虽然只是return left，但是会根据不同的情况落到不同的位置 //return left //那如果以right角度分析呢，如果nums[right]\u0026gt;target,那就应该返回right,如果nums[right]\u0026lt;target,那就应该返回right+1，因此也可以这么写； return right+1; } } 思路: // @Title: 搜索插入位置 (Search Insert Position) // @Author: qisiii // @Date: 2022-02-26 11:59:24 // @Runtime: 0 ms // @Memory: 40.5 MB // @comment: // @flag: class Solution { public int searchInsert(int[] nums, int target) { int left=0; int right=nums.length-1; while (left\u0026lt;=right){ int mid=left+(right-left)/2; if (nums[mid]==target){ return mid; }else if(nums[mid]\u0026gt;target){ right=mid-1; }else { left=mid+1; } } return left; } } "}