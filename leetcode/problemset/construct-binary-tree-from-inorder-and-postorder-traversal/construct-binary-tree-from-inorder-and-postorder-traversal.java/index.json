{"title":"从中序与后序遍历序列构造二叉树 (Construct Binary Tree from Inorder and Postorder Traversal)","permalink":"https://www.qisihub.cn/leetcode/problemset/construct-binary-tree-from-inorder-and-postorder-traversal/construct-binary-tree-from-inorder-and-postorder-traversal.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 从中序与后序遍历序列构造二叉树 (Construct Binary Tree from Inorder and Postorder Traversal) // @Author: qisiii // @Date: 2024-09-15 18:00:00 // @Runtime: 8 ms // @Memory: 82.7 MB // @comment: // @flag: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if (postorder.length == 0) { return null; } TreeNode root = new TreeNode(postorder[postorder.length - 1]); if (postorder.length == 1) { return root; } int index = findIndex(inorder, root.val); root.left = buildTree( Arrays.copyOfRange(inorder, 0, index), Arrays.copyOfRange(postorder, 0, index)); root.right = buildTree( Arrays.copyOfRange(inorder, index + 1, inorder.length), Arrays.copyOfRange(postorder, index, postorder.length-1)); return root; } private int findIndex(int[] inorder, int target) { for (int i = 0; i \u0026lt; inorder.length; i++) { if (inorder[i] == target) { return i; } } return -1; } } "}