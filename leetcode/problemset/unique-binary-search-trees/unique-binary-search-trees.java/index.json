{"title":"不同的二叉搜索树 (Unique Binary Search Trees)","permalink":"https://www.qisihub.cn/leetcode/problemset/unique-binary-search-trees/unique-binary-search-trees.java/","date":"0001-01-01T00:00:00Z","content":"思路: // @Title: 不同的二叉搜索树 (Unique Binary Search Trees) // @Author: qisiii // @Date: 2024-09-23 18:37:02 // @Runtime: 0 ms // @Memory: 39.3 MB // @comment: // @flag: /** *dp数组表示为n个节点二叉搜索树多少种 *当n为5的时候，假设用12345分别作为头结点，则具体的情况为 *1为头结点，左子树为空，右子树为4个节点,总情况为dp[0]*dp[4] *2为头节点，左子树有1个节点，右子树有3个节点，总情况为dp[1]*dp[3] *3为头节点，左子树有2个节点，右子树有2个节点，总情况为dp[2]*dp[2] *4为头节点，左子树有3个节点，右子树有1个节点，总情况为dp[3]*dp[1] *5为头结点，左子树为4个节点，右子树为空，总情况为dp[4]*dp[0] */ class Solution { public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { //左子树的情况*右子树的情况 dp[i] += (dp[j-1] * dp[i-j]); } } return dp[n]; } } "}