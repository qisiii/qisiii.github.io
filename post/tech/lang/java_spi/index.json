{"title":"Java的SPI机制","permalink":"https://www.qisihub.cn/post/tech/lang/java_spi/","date":"2023-03-17T00:00:00Z","content":"\n本质是将接口和实现进行解耦，使得外部程序可以提供不同的实现；\n实现机制为ServiceLoader通过迭代器进行\npublic Iterator\u0026lt;S\u0026gt; iterator() { return new Iterator\u0026lt;S\u0026gt;() { //之所以有knownProviders是为了处理多次迭代的情况，首次迭代的时候就将其缓存到了providers， //如果要重新加载所有的实现类，需要调用reload Iterator\u0026lt;Map.Entry\u0026lt;String,S\u0026gt;\u0026gt; knownProviders = providers.entrySet().iterator(); //本质是lookupIterator的方法 public boolean hasNext() { if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); } public S next() { if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); } public void remove() { throw new UnsupportedOperationException(); } }; } 从图中可以看出核心方法是hasNextService和nextService，acc是Java安全机制之一——SecurityManager和AccessController，可以忽略不看。\nprivate boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //PREFIX为META-INF/services/，service.getName是全限定名 String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); } catch (IOException x) { fail(service, \u0026#34;Error locating configuration files\u0026#34;, x); } } while ((pending == null) || !pending.hasNext()) { if (!configs.hasMoreElements()) { return false; } //将文件按行读取，每一行是list的一个元素 pending = parse(service, configs.nextElement()); } nextName = pending.next(); return true; } private S nextService() { if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class\u0026lt;?\u0026gt; c = null; try { //搞到类 c = Class.forName(cn, false, loader); } catch (ClassNotFoundException x) { fail(service, \u0026#34;Provider \u0026#34; + cn + \u0026#34; not found\u0026#34;); } if (!service.isAssignableFrom(c)) { fail(service, \u0026#34;Provider \u0026#34; + cn + \u0026#34; not a subtype\u0026#34;); } try { //实例化，并强转为接口类型 S p = service.cast(c.newInstance()); //缓存方便以后使用 providers.put(cn, p); return p; } catch (Throwable x) { fail(service, \u0026#34;Provider \u0026#34; + cn + \u0026#34; could not be instantiated\u0026#34;, x); } throw new Error(); // This cannot happen } 缺点是：不能按需加载，需要将所有的实现都遍历完，实例化完。\n应用场景：比如spring参考SPI机制搞的spring.factories，dubbo的@SPI\n参考文档： 深入理解 Java 中 SPI 机制\nJava SPI概念、实现原理、优缺点、应用场景、使用步骤、实战SPI案例-CSDN博客\n"}