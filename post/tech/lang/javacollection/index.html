<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Hashmap、ConcurrentHashMap、CopyOnWriteArrayList源码分析"><title>Java集合源码分析</title>
<link rel=canonical href=https://qisiii.github.io/post/tech/lang/javacollection/><link rel=stylesheet href=/scss/style.min.7657e19dfcc00117e827b40bd92bcea286037ffa4a33e95fc533eaea79d078f9.css><meta property='og:title' content="Java集合源码分析"><meta property='og:description' content="Hashmap、ConcurrentHashMap、CopyOnWriteArrayList源码分析"><meta property='og:url' content='https://qisiii.github.io/post/tech/lang/javacollection/'><meta property='og:site_name' content='起司的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Java'><meta property='article:published_time' content='2022-02-16T00:00:00+00:00'><meta property='article:modified_time' content='2024-09-19T17:03:52+00:00'><meta name=twitter:title content="Java集合源码分析"><meta name=twitter:description content="Hashmap、ConcurrentHashMap、CopyOnWriteArrayList源码分析"><link rel=alternate type=application/json href=https://qisiii.github.io/post/tech/lang/javacollection/index.json><link rel=alternate type=application/rss+xml href=https://qisiii.github.io/post/tech/lang/javacollection/index.xml><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-8NDCRP4S7S"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8NDCRP4S7S")}</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><span id=top></span></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huf89847f5290877d03a6309f0caaa56f1_43584_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>起司的博客</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/qisiii target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/index.xml target=_blank title=rss rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>首页|Home</span></a></li><li><a href=/post/friends target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-heart-handshake"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19.5 12.572 12 20l-7.5-7.428A5 5 0 1112 6.006a5 5 0 117.5 6.572"/><path d="M12 6 8.707 9.293a1 1 0 000 1.414l.543.543c.69.69 1.81.69 2.5.0l1-1a3.182 3.182.0 014.5.0l2.25 2.25"/><path d="M12.5 15.5l2 2"/><path d="M15 13l2 2"/></svg>
<span>友链|Friends</span></a></li><li><a href=/post/search target=_blank><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索|Search</span></a></li><li><a href=/leetcode target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-leetcode"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg>
<span>力扣|Leetcode</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#hashmap源码分析>hashmap源码分析</a><ol><li><a href=#构造函数>构造函数</a></li><li><a href=#tablesizefor>tableSizeFor</a></li><li><a href=#put>put()</a></li><li><a href=#hash>hash()</a></li><li><a href=#putval>putVal()</a></li><li><a href=#putmapentries>putMapEntries()</a></li><li><a href=#resize>resize()</a></li><li><a href=#treeifybin>treeifyBin</a></li></ol></li><li><a href=#linkedhashmap>LinkedHashMap</a></li><li><a href=#concurrenthashmap>ConcurrentHashMap</a><ol><li><a href=#putval-1>putval()</a></li><li><a href=#addcount>addCount()</a></li><li><a href=#helptransfer>helpTransfer（）</a></li><li><a href=#transfer>transfer()</a></li><li><a href=#为什么不需要锁>为什么不需要锁？</a></li></ol></li><li><a href=#copyonwritearraylist>CopyOnWriteArrayList</a></li><li><a href=#参考资料>参考资料</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/tech/>技术人生</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/tech/lang/javacollection/>Java集合源码分析</a></h2><h3 class=article-subtitle>Hashmap、ConcurrentHashMap、CopyOnWriteArrayList源码分析</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2022-02-16</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-hourglass-empty"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
<time class=article-time--reading>11分钟</time></div><span id=busuanzi_container_value_page_pv><i class="far fa-eye fa-fw"></i>
<span id=busuanzi_value_page_pv></span>&nbsp;</span><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg><div class=artile-time-reading><a href=https://qisiii.github.io/tags/java>#Java</a></div></footer></div></header><section class=article-content><h2 id=hashmap源码分析>hashmap源码分析</h2><h3 id=构造函数>构造函数</h3><p>initialCapacity 初始化大小，一般最好2次幂</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>public</span> <span class=n>HashMap</span><span class=p>(</span><span class=ne>int</span> <span class=n>initialCapacity</span><span class=p>,</span> <span class=ne>float</span> <span class=n>loadFactor</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>//</span><span class=err>初始化值默认是</span><span class=mi>16</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>throw</span> <span class=n>new</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s2>&#34;Illegal initial capacity: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                           <span class=n>initialCapacity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>initialCapacity</span> <span class=o>&gt;</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>initialCapacity</span> <span class=o>=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>loadFactor</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>Float</span><span class=o>.</span><span class=n>isNaN</span><span class=p>(</span><span class=n>loadFactor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>throw</span> <span class=n>new</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s2>&#34;Illegal load factor: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                           <span class=n>loadFactor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span><span class=n>The</span> <span class=nb>load</span> <span class=n>factor</span> <span class=k>for</span> <span class=n>the</span> <span class=nb>hash</span> <span class=n>table</span><span class=o>.</span> <span class=err>扩载因子，默认</span><span class=mf>0.75</span><span class=n>f</span>
</span></span><span class=line><span class=cl>    <span class=n>this</span><span class=o>.</span><span class=n>loadFactor</span> <span class=o>=</span> <span class=n>loadFactor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span><span class=n>The</span> <span class=n>next</span> <span class=n>size</span> <span class=n>value</span> <span class=n>at</span> <span class=n>which</span> <span class=n>to</span> <span class=n>resize</span> <span class=p>(</span><span class=n>capacity</span> <span class=o>*</span> <span class=nb>load</span> <span class=n>factor</span><span class=p>)</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=n>this</span><span class=o>.</span><span class=n>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=p>(</span><span class=n>initialCapacity</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span><span class=err>通过其他</span><span class=n>map初始化新的map</span>
</span></span><span class=line><span class=cl><span class=n>public</span> <span class=n>HashMap</span><span class=p>(</span><span class=n>Map</span><span class=o>&lt;</span><span class=err>?</span> <span class=k>extends</span> <span class=n>K</span><span class=p>,</span> <span class=err>?</span> <span class=k>extends</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>this</span><span class=o>.</span><span class=n>loadFactor</span> <span class=o>=</span> <span class=n>DEFAULT_LOAD_FACTOR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>putMapEntries</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=bp>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=tablesizefor>tableSizeFor</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * Returns a power of two size for the given target capacity.
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl> //生成一个大于等于 c 且为 2 的 N 次方的最小整数
</span></span><span class=line><span class=cl>static final int tableSizeFor(int cap) {
</span></span><span class=line><span class=cl>//减一是为了已经是2的幂次方的统一应对
</span></span><span class=line><span class=cl>    int n = cap - 1;
</span></span><span class=line><span class=cl>    //这一段的本质是将首位及其后面的数字都变为1，然后+1
</span></span><span class=line><span class=cl>    n |= n &gt;&gt;&gt; 1;
</span></span><span class=line><span class=cl>    n |= n &gt;&gt;&gt; 2;
</span></span><span class=line><span class=cl>    n |= n &gt;&gt;&gt; 4;
</span></span><span class=line><span class=cl>    n |= n &gt;&gt;&gt; 8;
</span></span><span class=line><span class=cl>    n |= n &gt;&gt;&gt; 16;
</span></span><span class=line><span class=cl>    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h3 id=put>put()</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public V put(K key, V value) {
</span></span><span class=line><span class=cl>    return putVal(hash(key), key, value, false, true);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>先了解一下hash
</span></span><span class=line><span class=cl>static final int hash(Object key) {
</span></span><span class=line><span class=cl>    int h;
</span></span><span class=line><span class=cl>    //高16为与低16为做异或
</span></span><span class=line><span class=cl>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//集合数组下标获取方式
</span></span><span class=line><span class=cl>if ((p = tab[i = (n - 1) &amp; hash]) == null)
</span></span><span class=line><span class=cl>    tab[i] = newNode(hash, key, value, null);
</span></span></code></pre></div><h3 id=hash>hash()</h3><p>一般称之为扰动函数，可以看出hash表进行存储的时候，用的是key的hash值，理论上是32位值，但数组没那么大呀，默认也才16，所以通过数组下标获取方式的源码来看</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> //所以是拿map的空间对hash掩码，
</span></span><span class=line><span class=cl> tab[i = (n - 1) &amp; hash]
</span></span></code></pre></div><p><img src=http://picgo.qisiii.asia/post/11-09-55-34-image.png loading=lazy></p><p><img src=http://picgo.qisiii.asia/post/11-09-56-00-image.png loading=lazy></p><p>我们可以将32位与n-1（其实刚好是掩码）做与操作，但是这样存储，会严重依赖于低位的信息，具体内容可以看<a class=link href=https://www.cnblogs.com/zhengwang/p/8136164.html target=_blank rel=noopener>HashMap中的hash函数 - 淡腾的枫 - 博客园</a>，所以官方在与之前，先让高位和低位进行异或，增加了随机性</p><h3 id=putval>putVal()</h3><p>将链表转化为树</p><p><em>TREEIFY_THRESHOLD=8</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//evict为false则表示处于创建中，查看调用方就只有clone，new Map(otherMap),readObject时是false
</span></span><span class=line><span class=cl>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
</span></span><span class=line><span class=cl>               boolean evict) {
</span></span><span class=line><span class=cl>    //数组加链表结构
</span></span><span class=line><span class=cl>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
</span></span><span class=line><span class=cl>    if ((tab = table) == null || (n = tab.length) == 0)
</span></span><span class=line><span class=cl>    //调用resize初始化
</span></span><span class=line><span class=cl>        n = (tab = resize()).length;
</span></span><span class=line><span class=cl>        //位置为空就直接塞进去，多线程的时候可能会导致值被覆盖
</span></span><span class=line><span class=cl>    if ((p = tab[i = (n - 1) &amp; hash]) == null)
</span></span><span class=line><span class=cl>        tab[i] = newNode(hash, key, value, null);
</span></span><span class=line><span class=cl>    else {
</span></span><span class=line><span class=cl>        Node&lt;K,V&gt; e; K k;
</span></span><span class=line><span class=cl>        //同key覆盖value
</span></span><span class=line><span class=cl>        if (p.hash == hash &amp;&amp;
</span></span><span class=line><span class=cl>            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
</span></span><span class=line><span class=cl>            e = p;
</span></span><span class=line><span class=cl>        //如果是红黑树
</span></span><span class=line><span class=cl>        else if (p instanceof TreeNode)
</span></span><span class=line><span class=cl>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
</span></span><span class=line><span class=cl>        else {
</span></span><span class=line><span class=cl>        //就只能是链表了
</span></span><span class=line><span class=cl>            for (int binCount = 0; ; ++binCount) {
</span></span><span class=line><span class=cl>            //节点的next为null，表示接着往后面插入
</span></span><span class=line><span class=cl>                if ((e = p.next) == null) {
</span></span><span class=line><span class=cl>                    p.next = newNode(hash, key, value, null);
</span></span><span class=line><span class=cl>                    //长度达到指定值，转为树，但是在treeifyBin中如果数组长度达不到64，那么只是扩容，而不是转为树
</span></span><span class=line><span class=cl>                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
</span></span><span class=line><span class=cl>                        treeifyBin(tab, hash);
</span></span><span class=line><span class=cl>                    break;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                //和某个节点和hash值相同，key也相同，那就证明插过了，跳出循环，重新赋值，所以get的时候，不可能只是hash
</span></span><span class=line><span class=cl>                if (e.hash == hash &amp;&amp;
</span></span><span class=line><span class=cl>                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
</span></span><span class=line><span class=cl>                    break;
</span></span><span class=line><span class=cl>                p = e;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if (e != null) { // existing mapping for key
</span></span><span class=line><span class=cl>            V oldValue = e.value;
</span></span><span class=line><span class=cl>            if (!onlyIfAbsent || oldValue == null)
</span></span><span class=line><span class=cl>                e.value = value;
</span></span><span class=line><span class=cl>            afterNodeAccess(e);
</span></span><span class=line><span class=cl>            return oldValue;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    //迭代器用的，记录结构修改次数，使用该值的迭代器，遍历时不能进行增删动作
</span></span><span class=line><span class=cl>    ++modCount;
</span></span><span class=line><span class=cl>    if (++size &gt; threshold)
</span></span><span class=line><span class=cl>        resize();
</span></span><span class=line><span class=cl>    afterNodeInsertion(evict);
</span></span><span class=line><span class=cl>    return null;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//get节点
</span></span><span class=line><span class=cl>final Node&lt;K,V&gt; getNode(int hash, Object key) {
</span></span><span class=line><span class=cl>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
</span></span><span class=line><span class=cl>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
</span></span><span class=line><span class=cl>        (first = tab[(n - 1) &amp; hash]) != null) {
</span></span><span class=line><span class=cl>        if (first.hash == hash &amp;&amp; // always check first node
</span></span><span class=line><span class=cl>            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
</span></span><span class=line><span class=cl>            return first;
</span></span><span class=line><span class=cl>        if ((e = first.next) != null) {
</span></span><span class=line><span class=cl>            if (first instanceof TreeNode)
</span></span><span class=line><span class=cl>                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
</span></span><span class=line><span class=cl>            do {
</span></span><span class=line><span class=cl>                if (e.hash == hash &amp;&amp;
</span></span><span class=line><span class=cl>                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
</span></span><span class=line><span class=cl>                    return e;
</span></span><span class=line><span class=cl>            } while ((e = e.next) != null);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return null;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h3 id=putmapentries>putMapEntries()</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>final</span> <span class=n>void</span> <span class=n>putMapEntries</span><span class=p>(</span><span class=n>Map</span><span class=o>&lt;</span><span class=err>?</span> <span class=k>extends</span> <span class=n>K</span><span class=p>,</span> <span class=err>?</span> <span class=k>extends</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>,</span> <span class=n>boolean</span> <span class=n>evict</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>//</span><span class=err>为空的时候初始化</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>table</span> <span class=o>==</span> <span class=n>null</span><span class=p>)</span> <span class=p>{</span> <span class=o>//</span> <span class=n>pre</span><span class=o>-</span><span class=n>size</span>
</span></span><span class=line><span class=cl>            <span class=ne>float</span> <span class=n>ft</span> <span class=o>=</span> <span class=p>((</span><span class=ne>float</span><span class=p>)</span><span class=n>s</span> <span class=o>/</span> <span class=n>loadFactor</span><span class=p>)</span> <span class=o>+</span> <span class=mf>1.0</span><span class=n>F</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=ne>int</span> <span class=n>t</span> <span class=o>=</span> <span class=p>((</span><span class=n>ft</span> <span class=o>&lt;</span> <span class=p>(</span><span class=ne>float</span><span class=p>)</span><span class=n>MAXIMUM_CAPACITY</span><span class=p>)</span> <span class=err>?</span>
</span></span><span class=line><span class=cl>                     <span class=p>(</span><span class=ne>int</span><span class=p>)</span><span class=n>ft</span> <span class=p>:</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>t</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=o>//</span><span class=err>过小的话就需要扩容</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>resize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=o>//</span><span class=err>依次插入</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Map</span><span class=o>.</span><span class=n>Entry</span><span class=o>&lt;</span><span class=err>?</span> <span class=k>extends</span> <span class=n>K</span><span class=p>,</span> <span class=err>?</span> <span class=k>extends</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=p>:</span> <span class=n>m</span><span class=o>.</span><span class=n>entrySet</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>K</span> <span class=n>key</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=n>getKey</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>V</span> <span class=n>value</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=n>getValue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>putVal</span><span class=p>(</span><span class=nb>hash</span><span class=p>(</span><span class=n>key</span><span class=p>),</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=bp>false</span><span class=p>,</span> <span class=n>evict</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=resize>resize()</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>final</span> <span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=n>resize</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=n>oldTab</span> <span class=o>=</span> <span class=n>table</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=n>oldCap</span> <span class=o>=</span> <span class=p>(</span><span class=n>oldTab</span> <span class=o>==</span> <span class=n>null</span><span class=p>)</span> <span class=err>?</span> <span class=mi>0</span> <span class=p>:</span> <span class=n>oldTab</span><span class=o>.</span><span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=n>oldThr</span> <span class=o>=</span> <span class=n>threshold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=n>newCap</span><span class=p>,</span> <span class=n>newThr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span><span class=err>原有空间大于</span><span class=mi>0</span><span class=err>，则扩大一倍</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>oldCap</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>threshold</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=n>MAX_VALUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>oldTab</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>newCap</span> <span class=o>=</span> <span class=n>oldCap</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                 <span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>newThr</span> <span class=o>=</span> <span class=n>oldThr</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span> <span class=o>//</span> <span class=n>double</span> <span class=n>threshold</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span><span class=err>剩下的都是初始化，指定为</span><span class=n>n</span><span class=err>，</span><span class=n>n</span><span class=o>!=</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>oldThr</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>//</span> <span class=n>initial</span> <span class=n>capacity</span> <span class=n>was</span> <span class=n>placed</span> <span class=ow>in</span> <span class=n>threshold</span>
</span></span><span class=line><span class=cl>        <span class=n>newCap</span> <span class=o>=</span> <span class=n>oldThr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span><span class=n>n为0</span><span class=err>，默认初始化</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>               <span class=o>//</span> <span class=n>zero</span> <span class=n>initial</span> <span class=n>threshold</span> <span class=n>signifies</span> <span class=n>using</span> <span class=n>defaults</span>
</span></span><span class=line><span class=cl>        <span class=n>newCap</span> <span class=o>=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>newThr</span> <span class=o>=</span> <span class=p>(</span><span class=ne>int</span><span class=p>)(</span><span class=n>DEFAULT_LOAD_FACTOR</span> <span class=o>*</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span><span class=err>修复大小</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>newThr</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=ne>float</span> <span class=n>ft</span> <span class=o>=</span> <span class=p>(</span><span class=ne>float</span><span class=p>)</span><span class=n>newCap</span> <span class=o>*</span> <span class=n>loadFactor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>newThr</span> <span class=o>=</span> <span class=p>(</span><span class=n>newCap</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span> <span class=n>ft</span> <span class=o>&lt;</span> <span class=p>(</span><span class=ne>float</span><span class=p>)</span><span class=n>MAXIMUM_CAPACITY</span> <span class=err>?</span>
</span></span><span class=line><span class=cl>                  <span class=p>(</span><span class=ne>int</span><span class=p>)</span><span class=n>ft</span> <span class=p>:</span> <span class=n>Integer</span><span class=o>.</span><span class=n>MAX_VALUE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>threshold</span> <span class=o>=</span> <span class=n>newThr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=n>SuppressWarnings</span><span class=p>({</span><span class=s2>&#34;rawtypes&#34;</span><span class=p>,</span><span class=s2>&#34;unchecked&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=n>newTab</span> <span class=o>=</span> <span class=p>(</span><span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[])</span><span class=n>new</span> <span class=ne>Node</span><span class=p>[</span><span class=n>newCap</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>table</span> <span class=o>=</span> <span class=n>newTab</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>oldTab</span> <span class=o>!=</span> <span class=n>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>oldCap</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>oldTab</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>!=</span> <span class=n>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>oldTab</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=o>//</span><span class=err>普通节点往数组扔，可能会移动，主要看首位是</span><span class=mi>1</span><span class=err>还是</span><span class=mi>0</span><span class=err>，</span><span class=mi>0</span><span class=err>的话不动，</span><span class=mi>1</span><span class=err>的话</span><span class=o>+</span><span class=n>newCap</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=o>.</span><span class=n>next</span> <span class=o>==</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>newTab</span><span class=p>[</span><span class=n>e</span><span class=o>.</span><span class=n>hash</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>newCap</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>e</span> <span class=n>instanceof</span> <span class=n>TreeNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=n>e</span><span class=p>)</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=n>this</span><span class=p>,</span> <span class=n>newTab</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>oldCap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span> <span class=p>{</span> <span class=o>//</span> <span class=n>preserve</span> <span class=n>order</span>
</span></span><span class=line><span class=cl>                <span class=o>//</span><span class=err>这是</span><span class=mf>1.8</span><span class=err>版本优化之后的，</span><span class=mf>1.7</span><span class=err>版本采用头插法，会在并发的时候导致链表成环，在</span><span class=n>get的时候就会死循环</span>
</span></span><span class=line><span class=cl>                <span class=o>//</span><span class=err>两个链表，一个链表用于存放还在原来桶的节点，一个链表用于放已经在扩容的桶的节点</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>loHead</span> <span class=o>=</span> <span class=n>null</span><span class=p>,</span> <span class=n>loTail</span> <span class=o>=</span> <span class=n>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>hiHead</span> <span class=o>=</span> <span class=n>null</span><span class=p>,</span> <span class=n>hiTail</span> <span class=o>=</span> <span class=n>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=ne>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>next</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=o>//</span><span class=err>将链表根据新旧桶区分，并先串起来</span>
</span></span><span class=line><span class=cl>                        <span class=o>//</span><span class=err>参考文档</span> <span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>blog</span><span class=o>.</span><span class=n>csdn</span><span class=o>.</span><span class=n>net</span><span class=o>/</span><span class=n>Unknownfuture</span><span class=o>/</span><span class=n>article</span><span class=o>/</span><span class=n>details</span><span class=o>/</span><span class=mi>105181447</span>
</span></span><span class=line><span class=cl>                        <span class=o>//</span><span class=err>这里</span><span class=n>e</span><span class=o>.</span><span class=n>hash</span><span class=o>&amp;</span><span class=n>oldCap就可以</span><span class=err>，是因为扩容前</span><span class=o>&amp;</span><span class=err>的都是</span><span class=n>oldCap</span><span class=o>-</span><span class=mi>1</span><span class=err>，比如</span><span class=n>oldCap为8</span><span class=err>，则</span><span class=o>&amp;</span><span class=err>的为</span><span class=mi>111</span><span class=err>，那么</span><span class=n>hash落入的必然是0</span><span class=o>-</span><span class=mi>7</span><span class=err>，但是现在</span><span class=o>&amp;</span><span class=err>的是</span><span class=mi>1000</span><span class=err>，就变成了会落到</span><span class=mi>0</span><span class=o>-</span><span class=mi>7</span><span class=err>或者</span><span class=mi>8</span><span class=o>-</span><span class=mi>15</span><span class=err>中，简单的一个首位，就可以区分两个链表</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>((</span><span class=n>e</span><span class=o>.</span><span class=n>hash</span> <span class=o>&amp;</span> <span class=n>oldCap</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=k>if</span> <span class=p>(</span><span class=n>loTail</span> <span class=o>==</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=n>loHead</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=k>else</span>
</span></span><span class=line><span class=cl>                                <span class=n>loTail</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=n>loTail</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=k>if</span> <span class=p>(</span><span class=n>hiTail</span> <span class=o>==</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=n>hiHead</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=k>else</span>
</span></span><span class=line><span class=cl>                                <span class=n>hiTail</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=n>hiTail</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span> <span class=k>while</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>next</span><span class=p>)</span> <span class=o>!=</span> <span class=n>null</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=o>//</span><span class=err>将两个链表的头放入桶中</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>loTail</span> <span class=o>!=</span> <span class=n>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>loTail</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=n>newTab</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>loHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>hiTail</span> <span class=o>!=</span> <span class=n>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>hiTail</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=n>newTab</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>oldCap</span><span class=p>]</span> <span class=o>=</span> <span class=n>hiHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>newTab</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img src=http://picgo.qisiii.asia/post/11-09-57-47-image.png loading=lazy></p><p><img src=http://picgo.qisiii.asia/post/11-09-57-59-image.png loading=lazy></p><h3 id=treeifybin>treeifyBin</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>treeifyBin</span><span class=p>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>tab</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hash</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>index</span><span class=p>;</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//node的总数过少，只会扩容，不会转树</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>tab</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tab</span><span class=p>.</span><span class=na>length</span><span class=p>)</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>MIN_TREEIFY_CAPACITY</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>resize</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tab</span><span class=o>[</span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>hash</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>hd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>,</span><span class=w> </span><span class=n>tl</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=c1>//根节点和尾结点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>replacementTreeNode</span><span class=p>(</span><span class=n>e</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>tl</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>hd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>;</span><span class=c1>//设置根节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>p</span><span class=p>.</span><span class=na>prev</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tl</span><span class=p>;</span><span class=c1>//互相指向</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>tl</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>tl</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>((</span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>next</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 到目前为止 也只是把Node对象转换成了TreeNode对象，把单向链表转换成了双向链表</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>tab</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hd</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>hd</span><span class=p>.</span><span class=na>treeify</span><span class=p>(</span><span class=n>tab</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=linkedhashmap>LinkedHashMap</h2><p><a class=link href=https://blog.csdn.net/justloveyou_/article/details/71713781 target=_blank rel=noopener>Map 综述(二):彻头彻尾理解 LinkedHashMap_Rico&rsquo;s Blogs-CSDN博客_linkedhashmap</a></p><p>额外维护了一个双向链表，所以可以记录顺序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//新建节点会调子类方法
</span></span><span class=line><span class=cl>Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {
</span></span><span class=line><span class=cl>    LinkedHashMap.Entry&lt;K,V&gt; p =
</span></span><span class=line><span class=cl>        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
</span></span><span class=line><span class=cl>    linkNodeLast(p);
</span></span><span class=line><span class=cl>    return p;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//将当前节点加到尾结点后面
</span></span><span class=line><span class=cl>private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {
</span></span><span class=line><span class=cl>    LinkedHashMap.Entry&lt;K,V&gt; last = tail;
</span></span><span class=line><span class=cl>    tail = p;
</span></span><span class=line><span class=cl>    if (last == null)
</span></span><span class=line><span class=cl>        head = p;
</span></span><span class=line><span class=cl>    else {
</span></span><span class=line><span class=cl>        p.before = last;
</span></span><span class=line><span class=cl>        last.after = p;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//删除节点之后
</span></span><span class=line><span class=cl>void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink
</span></span><span class=line><span class=cl>    LinkedHashMap.Entry&lt;K,V&gt; p =
</span></span><span class=line><span class=cl>        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
</span></span><span class=line><span class=cl>    //删除节点后，连接前置和后驱节点
</span></span><span class=line><span class=cl>    p.before = p.after = null;
</span></span><span class=line><span class=cl>    if (b == null)
</span></span><span class=line><span class=cl>        head = a;
</span></span><span class=line><span class=cl>    else
</span></span><span class=line><span class=cl>        b.after = a;
</span></span><span class=line><span class=cl>    if (a == null)
</span></span><span class=line><span class=cl>        tail = b;
</span></span><span class=line><span class=cl>    else
</span></span><span class=line><span class=cl>        a.before = b;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//在访问之后，比如是访问顺序的情况下，即accessOrder为true；
</span></span><span class=line><span class=cl>void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
</span></span><span class=line><span class=cl>    LinkedHashMap.Entry&lt;K,V&gt; last;
</span></span><span class=line><span class=cl>    if (accessOrder &amp;&amp; (last = tail) != e) {
</span></span><span class=line><span class=cl>        LinkedHashMap.Entry&lt;K,V&gt; p =
</span></span><span class=line><span class=cl>            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
</span></span><span class=line><span class=cl>        //关联e节点的前驱和后继
</span></span><span class=line><span class=cl>        p.after = null;
</span></span><span class=line><span class=cl>        if (b == null)
</span></span><span class=line><span class=cl>            head = a;
</span></span><span class=line><span class=cl>        else
</span></span><span class=line><span class=cl>            b.after = a;
</span></span><span class=line><span class=cl>        if (a != null)
</span></span><span class=line><span class=cl>            a.before = b;
</span></span><span class=line><span class=cl>        else
</span></span><span class=line><span class=cl>            last = b;
</span></span><span class=line><span class=cl>        //将e节点放到最后
</span></span><span class=line><span class=cl>        if (last == null)
</span></span><span class=line><span class=cl>            head = p;
</span></span><span class=line><span class=cl>        else {
</span></span><span class=line><span class=cl>            p.before = last;
</span></span><span class=line><span class=cl>            last.after = p;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        tail = p;
</span></span><span class=line><span class=cl>        ++modCount;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void afterNodeInsertion(boolean evict) { // possibly remove eldest
</span></span><span class=line><span class=cl>    LinkedHashMap.Entry&lt;K,V&gt; first;
</span></span><span class=line><span class=cl>    //通过重写可以实现LRU算法
</span></span><span class=line><span class=cl>    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
</span></span><span class=line><span class=cl>        K key = first.key;
</span></span><span class=line><span class=cl>        removeNode(hash(key), key, null, false, true);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h2 id=concurrenthashmap>ConcurrentHashMap</h2><blockquote><p>volatile的数组只针对数组的引用具有volatile的语义，而不是它的元素</p></blockquote><h3 id=putval-1>putval()</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>final V putVal(K key, V value, boolean onlyIfAbsent) {
</span></span><span class=line><span class=cl>    if (key == null || value == null) throw new NullPointerException();
</span></span><span class=line><span class=cl>    int hash = spread(key.hashCode());
</span></span><span class=line><span class=cl>    int binCount = 0;
</span></span><span class=line><span class=cl>    for (Node&lt;K,V&gt;[] tab = table;;) {
</span></span><span class=line><span class=cl>        Node&lt;K,V&gt; f; int n, i, fh;
</span></span><span class=line><span class=cl>        if (tab == null || (n = tab.length) == 0)
</span></span><span class=line><span class=cl>            tab = initTable();
</span></span><span class=line><span class=cl>            //查看是否有值，没值的话通过CAS保证写入
</span></span><span class=line><span class=cl>        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
</span></span><span class=line><span class=cl>            if (casTabAt(tab, i, null,
</span></span><span class=line><span class=cl>                         new Node&lt;K,V&gt;(hash, key, value, null)))
</span></span><span class=line><span class=cl>                break;                   // no lock when adding to empty bin
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        //正在扩容，所以头结点的hash会为-1（MOVED），这个时候要去帮助扩容
</span></span><span class=line><span class=cl>        else if ((fh = f.hash) == MOVED)
</span></span><span class=line><span class=cl>            tab = helpTransfer(tab, f);
</span></span><span class=line><span class=cl>        else {
</span></span><span class=line><span class=cl>            V oldVal = null;
</span></span><span class=line><span class=cl>            //cas也失败了，只能使用synchronized锁来
</span></span><span class=line><span class=cl>            synchronized (f) {
</span></span><span class=line><span class=cl>                if (tabAt(tab, i) == f) {
</span></span><span class=line><span class=cl>                    if (fh &gt;= 0) {
</span></span><span class=line><span class=cl>                        binCount = 1;
</span></span><span class=line><span class=cl>                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
</span></span><span class=line><span class=cl>                            K ek;
</span></span><span class=line><span class=cl>                            if (e.hash == hash &amp;&amp;
</span></span><span class=line><span class=cl>                                ((ek = e.key) == key ||
</span></span><span class=line><span class=cl>                                 (ek != null &amp;&amp; key.equals(ek)))) {
</span></span><span class=line><span class=cl>                                oldVal = e.val;
</span></span><span class=line><span class=cl>                                if (!onlyIfAbsent)
</span></span><span class=line><span class=cl>                                    e.val = value;
</span></span><span class=line><span class=cl>                                break;
</span></span><span class=line><span class=cl>                            }
</span></span><span class=line><span class=cl>                            Node&lt;K,V&gt; pred = e;
</span></span><span class=line><span class=cl>                            if ((e = e.next) == null) {
</span></span><span class=line><span class=cl>                                pred.next = new Node&lt;K,V&gt;(hash, key,
</span></span><span class=line><span class=cl>                                                          value, null);
</span></span><span class=line><span class=cl>                                break;
</span></span><span class=line><span class=cl>                            }
</span></span><span class=line><span class=cl>                        }
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                    else if (f instanceof TreeBin) {
</span></span><span class=line><span class=cl>                        Node&lt;K,V&gt; p;
</span></span><span class=line><span class=cl>                        binCount = 2;
</span></span><span class=line><span class=cl>                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
</span></span><span class=line><span class=cl>                                                       value)) != null) {
</span></span><span class=line><span class=cl>                            oldVal = p.val;
</span></span><span class=line><span class=cl>                            if (!onlyIfAbsent)
</span></span><span class=line><span class=cl>                                p.val = value;
</span></span><span class=line><span class=cl>                        }
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if (binCount != 0) {
</span></span><span class=line><span class=cl>                if (binCount &gt;= TREEIFY_THRESHOLD)
</span></span><span class=line><span class=cl>                    treeifyBin(tab, i);
</span></span><span class=line><span class=cl>                if (oldVal != null)
</span></span><span class=line><span class=cl>                    return oldVal;
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    addCount(1L, binCount);
</span></span><span class=line><span class=cl>    return null;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h3 id=addcount>addCount()</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//新增元素时，也就是在调用 putVal 方法后，为了通用，增加了个 check 入参，用于指定是否可能会出现扩容的情况
</span></span><span class=line><span class=cl>//check &gt;= 0 即为可能出现扩容的情况，例如 putVal方法中的调用
</span></span><span class=line><span class=cl>private final void addCount(long x, int check){
</span></span><span class=line><span class=cl>    ... ...
</span></span><span class=line><span class=cl>    if (check &gt;= 0) {
</span></span><span class=line><span class=cl>        Node&lt;K,V&gt;[] tab, nt; int n, sc;
</span></span><span class=line><span class=cl>        //检查当前集合元素个数 s 是否达到扩容阈值 sizeCtl ，扩容时 sizeCtl 为负数，依旧成立，同时还得满足数组非空且数组长度不能大于允许的数组最大长度这两个条件才能继续
</span></span><span class=line><span class=cl>        //这个 while 循环除了判断是否达到阈值从而进行扩容操作之外还有一个作用就是当一条线程完成自己的迁移任务后，如果集合还在扩容，则会继续循环，继续加入扩容大军，申请后面的迁移任务
</span></span><span class=line><span class=cl>        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) {
</span></span><span class=line><span class=cl>            int rs = resizeStamp(n);
</span></span><span class=line><span class=cl>            // sc &lt; 0 说明集合正在扩容当中
</span></span><span class=line><span class=cl>            if (sc &lt; 0) {
</span></span><span class=line><span class=cl>                //判断扩容是否结束或者并发扩容线程数是否已达最大值，如果是的话直接结束while循环
</span></span><span class=line><span class=cl>                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0)
</span></span><span class=line><span class=cl>                    break;
</span></span><span class=line><span class=cl>                //扩容还未结束，并且允许扩容线程加入，此时加入扩容大军中
</span></span><span class=line><span class=cl>                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
</span></span><span class=line><span class=cl>                    transfer(tab, nt);
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            //如果集合还未处于扩容状态中，则进入扩容方法，并首先初始化 nextTab 数组，也就是新数组
</span></span><span class=line><span class=cl>            //(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 为首个扩容线程所设置的特定值，后面扩容时会根据线程是否为这个值来确定是否为最后一个线程
</span></span><span class=line><span class=cl>            else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
</span></span><span class=line><span class=cl>                transfer(tab, null);
</span></span><span class=line><span class=cl>            s = sumCount();
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span></code></pre></div><h3 id=helptransfer>helpTransfer（）</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {
</span></span><span class=line><span class=cl>    Node&lt;K,V&gt;[] nextTab; int sc;
</span></span><span class=line><span class=cl>    // 如果 table 不是空 且 node 节点是转移类型，数据检验
</span></span><span class=line><span class=cl>    // 且 node 节点的 nextTable（新 table） 不是空，同样也是数据校验
</span></span><span class=line><span class=cl>    // 尝试帮助扩容
</span></span><span class=line><span class=cl>    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;
</span></span><span class=line><span class=cl>        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {
</span></span><span class=line><span class=cl>        int rs = resizeStamp(tab.length);
</span></span><span class=line><span class=cl>        // 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改
</span></span><span class=line><span class=cl>        // 且 sizeCtl  &lt; 0 （说明还在扩容）
</span></span><span class=line><span class=cl>        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;
</span></span><span class=line><span class=cl>               (sc = sizeCtl) &lt; 0) {
</span></span><span class=line><span class=cl>            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
</span></span><span class=line><span class=cl>                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
</span></span><span class=line><span class=cl>                transfer(tab, nextTab);
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return nextTab;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return table;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h3 id=transfer>transfer()</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {
</span></span><span class=line><span class=cl>    int n = tab.length, stride;
</span></span><span class=line><span class=cl>    //每个线程需要处理的桶的数量，不清楚这里为什么要除以8
</span></span><span class=line><span class=cl>    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
</span></span><span class=line><span class=cl>        stride = MIN_TRANSFER_STRIDE; // subdivide range
</span></span><span class=line><span class=cl>    if (nextTab == null) {            // initiating
</span></span><span class=line><span class=cl>        try {
</span></span><span class=line><span class=cl>            @SuppressWarnings(&#34;unchecked&#34;)
</span></span><span class=line><span class=cl>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
</span></span><span class=line><span class=cl>            nextTab = nt;
</span></span><span class=line><span class=cl>        } catch (Throwable ex) {      // try to cope with OOME
</span></span><span class=line><span class=cl>            sizeCtl = Integer.MAX_VALUE;
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        nextTable = nextTab;
</span></span><span class=line><span class=cl>        transferIndex = n;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    int nextn = nextTab.length;
</span></span><span class=line><span class=cl>    //这里节点hash改为了MOVE
</span></span><span class=line><span class=cl>    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
</span></span><span class=line><span class=cl>    boolean advance = true;
</span></span><span class=line><span class=cl>    boolean finishing = false; // to ensure sweep before committing nextTab
</span></span><span class=line><span class=cl>    for (int i = 0, bound = 0;;) {
</span></span><span class=line><span class=cl>        Node&lt;K,V&gt; f; int fh;
</span></span><span class=line><span class=cl>        while (advance) {
</span></span><span class=line><span class=cl>            int nextIndex, nextBound;
</span></span><span class=line><span class=cl>            //当i没有走到bound时，表明当前都还是一批
</span></span><span class=line><span class=cl>            if (--i &gt;= bound || finishing)
</span></span><span class=line><span class=cl>                advance = false;
</span></span><span class=line><span class=cl>            //跳出循环，表明迁移完了，会用到下面i&lt;0的条件
</span></span><span class=line><span class=cl>            else if ((nextIndex = transferIndex) &lt;= 0) {
</span></span><span class=line><span class=cl>                i = -1;
</span></span><span class=line><span class=cl>                advance = false;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            //这里实际上是从n开始逆序分配，一次减少指定步长，然后在for循环中处理这一批
</span></span><span class=line><span class=cl>            else if (U.compareAndSwapInt
</span></span><span class=line><span class=cl>                     (this, TRANSFERINDEX, nextIndex,
</span></span><span class=line><span class=cl>                      nextBound = (nextIndex &gt; stride ?
</span></span><span class=line><span class=cl>                                   nextIndex - stride : 0))) {
</span></span><span class=line><span class=cl>                bound = nextBound;
</span></span><span class=line><span class=cl>                i = nextIndex - 1;
</span></span><span class=line><span class=cl>                advance = false;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>                    //i&lt;0存在多种情况，比如单个线程单次干完了，再次分配的时候，发现TRANSFERINDEX还没到0，就又分到了一批，因此还得继续
</span></span><span class=line><span class=cl>            //多个线程都分配了，当前线程尝试再次分配的时候，发现，i已经为-1了，这个时候，这个线程就可以撤了
</span></span><span class=line><span class=cl>        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
</span></span><span class=line><span class=cl>            int sc;
</span></span><span class=line><span class=cl>            //如果全部结束，table要更新，阈值也要更新
</span></span><span class=line><span class=cl>            if (finishing) {
</span></span><span class=line><span class=cl>                nextTable = null;
</span></span><span class=line><span class=cl>                table = nextTab;
</span></span><span class=line><span class=cl>                //1.5n=2n-0.5n，实际是0.75*2n
</span></span><span class=line><span class=cl>                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
</span></span><span class=line><span class=cl>                return;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            //所以能到这里的，都是自己活干完的线程，来这里-1；
</span></span><span class=line><span class=cl>            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
</span></span><span class=line><span class=cl>                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
</span></span><span class=line><span class=cl>                    return;
</span></span><span class=line><span class=cl>                finishing = advance = true;
</span></span><span class=line><span class=cl>                i = n; // recheck before commit
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        //这里是直接移动到新数组
</span></span><span class=line><span class=cl>        else if ((f = tabAt(tab, i)) == null)
</span></span><span class=line><span class=cl>            advance = casTabAt(tab, i, null, fwd);
</span></span><span class=line><span class=cl>        else if ((fh = f.hash) == MOVED)
</span></span><span class=line><span class=cl>        //已经被线程处理了
</span></span><span class=line><span class=cl>            advance = true; // already processed
</span></span><span class=line><span class=cl>        else {
</span></span><span class=line><span class=cl>        //这里会锁节点，所以实际过程中，put和扩容会抢占，由于任意一方可能更改，如果是put则可能是新值，如果是扩容，则可能变为MOVE，因此拿到锁之后要先检查一遍是否和原来相等
</span></span><span class=line><span class=cl>            synchronized (f) {
</span></span><span class=line><span class=cl>                if (tabAt(tab, i) == f) {
</span></span><span class=line><span class=cl>                    Node&lt;K,V&gt; ln, hn;
</span></span><span class=line><span class=cl>                    if (fh &gt;= 0) {
</span></span><span class=line><span class=cl>                        int runBit = fh &amp; n;
</span></span><span class=line><span class=cl>                        //lastRun的机制为最后一次变动的地方，这样没有变动的节点就可以直接拼在下面的ln或者hn中了
</span></span><span class=line><span class=cl>                        Node&lt;K,V&gt; lastRun = f;
</span></span><span class=line><span class=cl>                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {
</span></span><span class=line><span class=cl>                            int b = p.hash &amp; n;
</span></span><span class=line><span class=cl>                            //只有和之前不一样，lastRun才会变动
</span></span><span class=line><span class=cl>                            if (b != runBit) {
</span></span><span class=line><span class=cl>                                runBit = b;
</span></span><span class=line><span class=cl>                                lastRun = p;
</span></span><span class=line><span class=cl>                            }
</span></span><span class=line><span class=cl>                        }
</span></span><span class=line><span class=cl>                        if (runBit == 0) {
</span></span><span class=line><span class=cl>                            ln = lastRun;
</span></span><span class=line><span class=cl>                            hn = null;
</span></span><span class=line><span class=cl>                        }
</span></span><span class=line><span class=cl>                        else {
</span></span><span class=line><span class=cl>                            hn = lastRun;
</span></span><span class=line><span class=cl>                            ln = null;
</span></span><span class=line><span class=cl>                        }
</span></span><span class=line><span class=cl>                        //逆序构建两个链表，但是由于lastRun的存在，持有lastRun节点的链表，lastRun前面是逆序，后面是正序
</span></span><span class=line><span class=cl>                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {
</span></span><span class=line><span class=cl>                            int ph = p.hash; K pk = p.key; V pv = p.val;
</span></span><span class=line><span class=cl>                            //和hashmap同理
</span></span><span class=line><span class=cl>                            if ((ph &amp; n) == 0)
</span></span><span class=line><span class=cl>                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
</span></span><span class=line><span class=cl>                            else
</span></span><span class=line><span class=cl>                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
</span></span><span class=line><span class=cl>                        }
</span></span><span class=line><span class=cl>                        //将两个链表放到新数组的两个位置，同时标记旧数组当前节点为MOVE，虽然当前节点已经迁移成功了，但是要呼唤其他线程来帮忙
</span></span><span class=line><span class=cl>                        setTabAt(nextTab, i, ln);
</span></span><span class=line><span class=cl>                        setTabAt(nextTab, i + n, hn);
</span></span><span class=line><span class=cl>                        setTabAt(tab, i, fwd);
</span></span><span class=line><span class=cl>                        advance = true;
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                    //暂不分析
</span></span><span class=line><span class=cl>                    else if (f instanceof TreeBin) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h3 id=为什么不需要锁>为什么不需要锁？</h3><p>在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一</p><p>get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。</p><p>数组用volatile修饰主要是保证在数组扩容的时候保证可见性。</p><h2 id=copyonwritearraylist>CopyOnWriteArrayList</h2><p>ArrayList是线程不安全的，看add方法就知道了，很有可能多个线程取到的size都是相同的，然后又同时更新了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>public</span><span class=w> </span><span class=nb>boolean</span><span class=w> </span><span class=k>add</span><span class=p>(</span><span class=n>E</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ensureCapacityInternal</span><span class=p>(</span><span class=k>size</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>  </span><span class=o>//</span><span class=w> </span><span class=n>Increments</span><span class=w> </span><span class=n>modCount</span><span class=o>!!</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>elementData</span><span class=p>[</span><span class=k>size</span><span class=o>++</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span></code></pre></div><p>CopyOnWrite字如其名，当存在写的时候，会先将数据复制一份出来，然后对复制的进行修改，然后将引用指过去。</p><p>为啥这么设计呢？因为这样和读可以不冲突了，而写的时候都是通过加锁</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>public</span><span class=w> </span><span class=nb>boolean</span><span class=w> </span><span class=k>add</span><span class=p>(</span><span class=n>E</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>final</span><span class=w> </span><span class=n>ReentrantLock</span><span class=w> </span><span class=k>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>this</span><span class=p>.</span><span class=k>lock</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>lock</span><span class=p>.</span><span class=k>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>try</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>Object</span><span class=p>[]</span><span class=w> </span><span class=n>elements</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getArray</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>int</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>elements</span><span class=p>.</span><span class=k>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>Object</span><span class=p>[]</span><span class=w> </span><span class=n>newElements</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=n>copyOf</span><span class=p>(</span><span class=n>elements</span><span class=p>,</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>newElements</span><span class=p>[</span><span class=n>len</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>setArray</span><span class=p>(</span><span class=n>newElements</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>}</span><span class=w> </span><span class=n>finally</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>private</span><span class=w> </span><span class=n>E</span><span class=w> </span><span class=k>get</span><span class=p>(</span><span class=k>Object</span><span class=p>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=nb>int</span><span class=w> </span><span class=k>index</span><span class=p>)</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=n>E</span><span class=p>)</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=k>index</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>public</span><span class=w> </span><span class=n>E</span><span class=w> </span><span class=n>remove</span><span class=p>(</span><span class=nb>int</span><span class=w> </span><span class=k>index</span><span class=p>)</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>final</span><span class=w> </span><span class=n>ReentrantLock</span><span class=w> </span><span class=k>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>this</span><span class=p>.</span><span class=k>lock</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>lock</span><span class=p>.</span><span class=k>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>try</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>Object</span><span class=p>[]</span><span class=w> </span><span class=n>elements</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getArray</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>int</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>elements</span><span class=p>.</span><span class=k>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>E</span><span class=w> </span><span class=n>oldValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>get</span><span class=p>(</span><span class=n>elements</span><span class=p>,</span><span class=w> </span><span class=k>index</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>int</span><span class=w> </span><span class=n>numMoved</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>//</span><span class=err>是不是最后一个</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>numMoved</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>setArray</span><span class=p>(</span><span class=n>Arrays</span><span class=p>.</span><span class=n>copyOf</span><span class=p>(</span><span class=n>elements</span><span class=p>,</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>//</span><span class=err>如果不是，则先复制前半分，再复制后半份</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>Object</span><span class=p>[]</span><span class=w> </span><span class=n>newElements</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=k>Object</span><span class=p>[</span><span class=n>len</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>System</span><span class=p>.</span><span class=n>arraycopy</span><span class=p>(</span><span class=n>elements</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>newElements</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=k>index</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>System</span><span class=p>.</span><span class=n>arraycopy</span><span class=p>(</span><span class=n>elements</span><span class=p>,</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>newElements</span><span class=p>,</span><span class=w> </span><span class=k>index</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                             </span><span class=n>numMoved</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>setArray</span><span class=p>(</span><span class=n>newElements</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>oldValue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>}</span><span class=w> </span><span class=n>finally</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=参考资料>参考资料</h2><p><a class=link href=https://blog.csdn.net/pcwl1206/article/details/85040309 target=_blank rel=noopener>【搞定Java8新特性】之Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析_Java学习-CSDN博客</a></p><p><a class=link href=https://coolshell.cn/articles/9606.html target=_blank rel=noopener>疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p><p><a class=link href=https://blog.csdn.net/weixin_41565013/article/details/93190786 target=_blank rel=noopener>深入理解HashMap(三)resize方法解析_BodyCoding-CSDN博客_hashmap resize()</a></p><p><a class=link href=https://blog.csdn.net/sayWhat_sayHello/article/details/83120324 target=_blank rel=noopener>HashMap的最大容量为什么是2的30次方(1左移30)?_与望-CSDN博客</a></p><p><a class=link href=https://blog.csdn.net/ZOKEKAI/article/details/90051567 target=_blank rel=noopener>ConcurrentHashMap1.8 - 扩容详解_concurrenthashmap1.8的扩容机制-CSDN博客</a></p><p><a class=link href=https://blog.csdn.net/Unknownfuture/article/details/105369019 target=_blank rel=noopener>ConcurrentHashMap之transfer()扩容深入源码分析-CSDN博客</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 2024-09-19</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/tech/lang/java_spi/><div class=article-details><h2 class=article-title>Java的SPI机制</h2></div></a></article><article><a href=/post/tech/distributed/zookeeper/zab/><div class=article-details><h2 class=article-title>Zookeeper源码分析-Zab协议</h2></div></a></article><article><a href=/post/tech/distributed/zookeeper/election/><div class=article-details><h2 class=article-title>Zookeeper源码分析-选举机制</h2></div></a></article><article><a href=/post/tech/distributed/zookeeper/watch/><div class=article-details><h2 class=article-title>Zookeeper源码分析-watch机制</h2></div></a></article><article><a href=/post/tech/distributed/zookeeper/zookeeperservermain/><div class=article-details><h2 class=article-title>Zookeeper源码学习-单机部分通信组件</h2></div></a></article></div></div></aside><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script><script src=https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js></script><script>const gitalk=new Gitalk({clientID:"Ov23libDgguDHlLK57yi",clientSecret:"bfd2cba55f272f4919357e37e54e4f4697cdd7d0",repo:"qisiii.github.io",owner:"qisiii",admin:["qisiii"],distractionFreeMode:!1,id:md5(location.pathname)});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk-container").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}gitalk.render("gitalk-container")})()</script><a href=#top aria-label="go to top" class=top-link id=top-link style=display:none><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-chevron-up"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 15l6-6 6 6"/></svg>
</a><script src=https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript>$(window).scroll(function(){$(this).scrollTop()>300?$("#top-link").show():$("#top-link").hide()})</script><footer class=site-footer><section class=copyright>&copy;
2022 -
2024 起司</section><section class=powerby><a href=https://beian.miit.gov.cn/ target=_blank>京ICP备2023017017号-1</a><br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css><section><span id=busuanzi_container_value_site_pv><i class="far fa-eye fa-fw"></i>
<span id=busuanzi_value_site_pv></span>次
</span>&nbsp;|&nbsp;
<span id=busuanzi_container_value_site_uv><i class="fa fa-user" aria-hidden=true></i>
<span id=busuanzi_value_site_uv></span>人次</span></section></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>