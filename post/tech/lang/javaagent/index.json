{"title":"JavaAgent技术","permalink":"https://www.qisihub.cn/post/tech/lang/javaagent/","date":"2023-09-10T00:00:00Z","content":" 在定位公司问题的时候，需要了解一下skywalking的相关知识，而agent就提上了日程。\n官网文档\nAgent技术是Jdk在1.5版本之后，所提供的一个在jvm启动前后对部分java类代理加强的机制。由于是直接修改字节码，并不会对业务代码有注入，所以可以很好的应用于监控或者热部署等场景。\n正常所提到的Agent一般都是部署成jar包的样子，比如agent-1.0-SNAPSHOT.jar。\n在这个jar包中，要添加一个MANIFEST.MF文件，在文件中指定jar包的代理类，比如下面代码中的Premain-Class。\n在对应的代理类，要实现一个permain方法或者agentmain方法，这样jvm可以通过MANIFEST找到类，通过类再找到对应的方法，从而进行加强，所以加强逻辑是在permain方法或者agentmain方法内部实现的。\nManifest-Version: 1.0 Built-By: qisi Premain-Class: com.qisi.agent.InterviewAgent Agent-Class: com.qisi.agent.InterviewAgent Can-Redefine-Classes: true Can-Retransform-Classes: true Class-Path: byte-buddy-1.10.22.jar Created-By: Apache Maven 3.8.1 Build-Jdk: 1.8.0_332 public class InterviewAgent { public static void premain(String agentArgs, Instrumentation instrumentation) { } public static void agentmain(String agentArgs, Instrumentation instrumentation) { } } 而如果在permain或者agentmain方法打上debug可以发现，执行时是通过sun.instrument.InstrumentationImpl#loadClassAndCallPremain和sun.instrument.InstrumentationImpl#loadClassAndCallAgentmain两个方法通过反射来执行到我们指定的类的。\nAgent技术有两种场景，一种是在jvm启动之前，通过-javaagent:path来指定jar包，像是skywalking就是采用的这种方式；另一种则是在jvm启动之后，通过attach指定的进程，对jvm中的类进行加强，arthas就是采用的这种方式。\n在具体介绍这两种方式之前，需要先讲一下Instrumentation相关类和接口\njava.lang.Instrumentation Instrumentation Instrumentation相关的类都在java.lang.Instrumentation包下，两个异常，两个接口，一个类。 两个异常在这里不做介绍，功能就像类名一样。核心的其实是Instrumentation接口，本文仅关注红框内的几个方法。这几个方法都是通过permain和agentmain获取到的instrumentation实例进行的操作。\n从时间发展来看，其中jdk1.5开始支持的是下面几个方法，也就是说在jdk5的时候，仅支持添加和移除类转换器，且添加的类转换器只能在加载和重定义的时候使用。就是说如果类没有加载，那么通过addTransformer方法注册的ClassFileTransformer就可以对这个类进行增强，否则一旦类已经加载完毕，则只能通过redefineClasses，完全替换类定义再次触发loadClass来增强\naddTransformer(ClassFileTransformer transformer) removeTransformer(ClassFileTransformer transformer) isRedefineClassesSupported();//依赖于MANIFEST中的Can-Redefine-Classes值 redefineClasses(ClassDefinition... definitions) 而从jdk1.6开始，增加了一个retransformClasses的概念。retransform和redefine的区别，前者是在原有类的基础上进行修改，后者则是完全重定义，不使用原有类做任何参考。 需要注意的事，只有在首次调用addTransformer时，将canRetransform设置为true的类，才可以被重新转换。\naddTransformer(ClassFileTransformer transformer, boolean canRetransform); isRetransformClassesSupported(); retransformClasses(Class\u0026lt;?\u0026gt;... classes)//依赖于MANIFEST中的Can-Retransform-Classes值 isModifiableClass(Class\u0026lt;?\u0026gt; theClass); ClassFileTransformer、ClassDefinition 这两个类其实都是Instrumentation接口方法的入参，其中用的比较多的应该是ClassFileTransformer。这个类只有一个transform，jvm类加载的时候都会调用一遍这个方法。如果需要加强，那么就利用给定的参数，进行字节码的改动，将改动后的字节码作为返回值返回；如果无需增强，则直接返回null即可。\nbyte[] transform( ClassLoader loader, String className, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) ClassDefinition也类似，不过是在对象里重新绑定class和byte的关系\npublic final class ClassDefinition { /** * The class to redefine */ private final Class\u0026lt;?\u0026gt; mClass; /** * The replacement class file bytes */ private final byte[] mClassFile; 实践 MANIFEST.MF配置 在pom文件中添加下面的代码，根据需要修改参数值\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;addMavenDescriptor\u0026gt;false\u0026lt;/addMavenDescriptor\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;manifestEntries\u0026gt; \u0026lt;Premain-Class\u0026gt; com.qisi.agent.InterviewByteButtyAgent \u0026lt;/Premain-Class\u0026gt; \u0026lt;Agent-Class\u0026gt; com.qisi.agent.InterviewByteButtyAgent \u0026lt;/Agent-Class\u0026gt; \u0026lt;Can-Redefine-Classes\u0026gt; true \u0026lt;/Can-Redefine-Classes\u0026gt; \u0026lt;Can-Retransform-Classes\u0026gt; true \u0026lt;/Can-Retransform-Classes\u0026gt; \u0026lt;Built-By\u0026gt; qisi \u0026lt;/Built-By\u0026gt; \u0026lt;/manifestEntries\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; -javaagent: 在这种方式下，起作用的是permain，也就是说-javaagent和permain方法是配套使用的。 核心就是添加一个自定义的ClassFileTransformer，可以另起一个类，也可以这样匿名类。 如果只是熟悉流程可以像下面一样，直接打印一些日志，不去修改类；\npublic static void premain(String agentArgs, Instrumentation instrumentation) { System.out.println(\u0026#34;enhance by premain,params:\u0026#34;+agentArgs); instrumentation.addTransformer(new ClassFileTransformer() { @Override public byte[] transform(ClassLoader loader, String className, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { System.out.println(\u0026#34;premain load Class :\u0026#34; + className); return classfileBuffer; } }, true); } 如果要真实修改，需要引入asm javassist bytebuddy等修改字节码的框架。下面这部分就是使用了bytebuddy，作用是让任何类的testAgent方法，都返回固定值transformed\npublic static void premain(String agentArgs, Instrumentation instrumentation) throws ClassNotFoundException { System.out.println(\u0026#34;enhance by permain InterviewByteButtyAgent,params:\u0026#34;+agentArgs); new AgentBuilder.Default().type(any()).transform(new AgentBuilder.Transformer() { @Override public DynamicType.Builder\u0026lt;?\u0026gt; transform(DynamicType.Builder\u0026lt;?\u0026gt; builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) { return builder.method(named(\u0026#34;testAgent\u0026#34;)) .intercept(FixedValue.value(\u0026#34;transformed\u0026#34;)); } }).installOn(instrumentation); } 编写完之后，就可以在任意项目添加一个存在testAgent方法的进行尝试了，比如 java -javaagent:/xxxx/path/agent-1.0-SNAPSHOT.jar=key1:value1,key2:value2 -jar AppDemo.jar\nattach agentmain 这种方式需要实现agentmain方法，和permian不太一样的地方是需要在addTransformer之后触发需要retransformClasses想要加强的类。\npublic static void agentmain(String agentArgs, Instrumentation instrumentation) { System.out.println(\u0026#34;enhance by agentmain,params:\u0026#34;+agentArgs); instrumentation.addTransformer(new ClassFileTransformer() { @Override public byte[] transform(ClassLoader loader, String className, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { System.out.println(\u0026#34;agentmain load Class :\u0026#34; + className); return classfileBuffer; } }, true); try { instrumentation.retransformClasses(Class.forName(\u0026#34;com.qisi.mybatis.app.controller.FirstRequestController\u0026#34;)); } catch (UnmodifiableClassException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } 同样，提供一个bytebuddy的例子，下面这个则是指定修改FirstRequestController的testAgent方法的返回值为transformed\npublic static void agentmain(String agentArgs, Instrumentation instrumentation) throws ClassNotFoundException { System.out.println(\u0026#34;enhance by agentmain InterviewByteButtyAgent,params:\u0026#34;+agentArgs); //这里RedefinitionStrategy必须注意，默认的DISABLED是不支持retransform new AgentBuilder.Default().with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION).type(new AgentBuilder.RawMatcher() { @Override public boolean matches(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain) { return typeDescription.getName().contains(\u0026#34;FirstRequestController\u0026#34;); } }).transform(new AgentBuilder.Transformer() { @Override public DynamicType.Builder\u0026lt;?\u0026gt; transform(DynamicType.Builder\u0026lt;?\u0026gt; builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) { System.out.println(\u0026#34;enhance\u0026#34;+typeDescription.getName()); return builder.method(named(\u0026#34;testAgent\u0026#34;)) .intercept(FixedValue.value(\u0026#34;transformed\u0026#34;)); } //这里采用disableClassFormatChanges的方案，好像还可以使用advice }).disableClassFormatChanges().installOn(instrumentation); try { instrumentation.retransformClasses(Class.forName(\u0026#34;com.qisi.mybatis.app.controller.FirstRequestController\u0026#34;)); } catch (UnmodifiableClassException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } VirtualMachine 不同于-javaagent命令，这里需要使用自jdk6开始提供的VirtualMachine类，在tool.jar包里 下面的方法是我参考arthas写的一个attach的流程，选择我们想要attach的进程，然后加载我们上面写好的jar包就好了。\npublic class AgentTest { public static void main(String[] args) throws IOException, AttachNotSupportedException { String pid = null; try { Process jps = Runtime.getRuntime().exec(\u0026#34;jps\u0026#34;); InputStream inputStream = jps.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } System.out.println(\u0026#34;选择要attach的进程\u0026#34;); pid= new Scanner(System.in).nextLine(); System.out.println(\u0026#34;选择的pid是\u0026#34;+pid); } catch (IOException e) { e.printStackTrace(); } for (VirtualMachineDescriptor virtualMachineDescriptor : VirtualMachine.list()) { if (virtualMachineDescriptor.id().equals(pid)){ VirtualMachine attach = VirtualMachine.attach(virtualMachineDescriptor); try { attach.loadAgent(\u0026#34;/xxxxx/agent/target/agent-1.0-SNAPSHOT.jar\u0026#34;,\u0026#34;参数1，参数2\u0026#34;); } catch (AgentLoadException e) { e.printStackTrace(); } catch (AgentInitializationException e) { e.printStackTrace(); } finally { attach.detach(); } break; } } } } 参考文档： 探秘 Java 热部署二（Java agent premain）\nJAVA热更新1:Agent方式热更 | 花隐间-JAVA游戏技术解决方案\nByteBuddy入门教程\n"}