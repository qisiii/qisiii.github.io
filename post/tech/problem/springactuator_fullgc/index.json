{"title":"偷偷开启的监控在吃内存","permalink":"https://www.qisihub.cn/post/tech/problem/springactuator_fullgc/","date":"2023-12-10T00:00:00Z","content":"整体复盘： 一个不算普通的周五中午，同事收到了大量了cpu异常的报警。根据报警表现和通过arthas查看，很明显的问题就是内存不足，疯狂无效gc。而且结合arthas和gc日志查看，老年代打满了，gc不了一点。既然问题是内存问题，那么老样子，通过jmap和heap dump 文件分析。\n不感兴趣的可以直接看结论\n通过jmap命令查看的类似下图，并没有项目中明显的自定义类，而占空间最大的又是char数组，当时线上占900M左右，整个老年代也就1.8个G；此时dump文件同事还在下载，网速较慢。\n通过业务日志查看，很多restTempalte请求报错，根据报错信息可知是某xx认证过期了，导致接收到回调，业务处理时调接口报错了；查询数据库，大概有20多万回调。根据过期时间和内存监控，大概能对的上号，表明内存异常和这个认证过期有关。怀疑度最高的只有回调以及回调补偿任务，但是一行一行代码看过去，并不觉得有什么异常。\n在dump文件下载完之后，使用jvisualvm分析，最多的char里大部分都是一些请求的路径，如“example/test/1\u0026quot;，”“example/test/2\u0026quot;之类的，都是接口统一，但是参数不一样，因为是GET请求，所以实际路径都不一样。Jvisualvm点击gc_root又一直计算不出来，在等待计算的过程中，一度走了弯路（百度搜索到ImmutableTag这个类在skywalking有用过，但skywalking由于是jar包进行代理，项目中不存在对应的源码，所以又不得不下载公司的jar包反编译，然后去找http相关插件里翻源码，只是为了看一下ImmutableTag的具体结构）；此时，我们大概归纳到是http的监控在统计一些指标物料时，没有释放接口路径所引用的对象导致老年代打满）。 在gc_root终于计算出来之后，更是肯定了这个想法，但是hikari怎么可能监听http呢？\n于是又现下载jprofiler，通过jprofiler的聚类，确定了一定是这个Meter导致的，而通过JProfile的分析，终于定位到是\norg.springframework.boot.actuate.metrics.web.client.MetricsClientHttpRequestInterceptor#intercept这个类。然后发现，MetricsClientHttpRequestInterceptor 持有一个meterRegistry，里面核心是个map，所以一定是map没有清除。和我们最开始想的skywalking不一样，是springboot配套的监控，根据依赖分析，发现是有次需求引入了redisson-spring-boot-starter，而redisson依赖了spring-boot-starter-actuator，这东西默认启动了，会拦截所有的RestTempalte请求，然后记录一些指标。\n所以问题变成了，为什么map没有清掉已经执行完的请求？\n我之前并没有研究过spring的actuator，只是看过skywalking的流程，所以我以为也和skywalking一样，记录然后上报，上报之后删除本地的。所以当时怀疑，难道是和我们请求都异常了有关，但是正如下面的代码，无论是否异常，都是执行finnally，所以又不太可能。\nClientHttpResponse response = null; try { response = execution.execute(request, body); return response; } finally { try { getTimeBuilder(request, response).register(this.meterRegistry).record(System.nanoTime() - startTime, TimeUnit.NANOSECONDS); } catch (Exception ex) { logger.info(\u0026#34;Failed to record metrics.\u0026#34;, ex); } if (urlTemplate.get().isEmpty()) { urlTemplate.remove(); } } 而在我自己尝试复现之后，micrometer的指标根本不会被自动清除，生命周期和应用的生命周期一样。因为并不存在上报，数据全部在内存（虽然可以导出到数据库，但并没有深入研究）。其实也合理，因为如果要通过Grafana等可视化平台查看的时候，我们也希望查看任意时刻的监控。不过看代码应该是有留一些手动删除的，应该是页面操作之类的才会触发。\n结论 所以到此为止，可以定结论，那就是因为引入了redisson-spring-boot-starter，导致不知情引入了spring-boot-starter-actuator。\n因此默认开启了http.client.request指标的监控，关于http.client.request，有一个属性是maxUriTags，默认值是100，其作用是限制meterMap里uri的个数。但是maxUriTags起作用的地方MeterFilter没有生效。\n由于maxUriTags没有生效，导致监控信息里的uri因为业务大量的GET请求中存在唯一id，本身就很占内存。压死内存的最后稻草是认证过期和补偿任务。补偿任务为保证及时性一直在频繁执行，而接口的uri里两个变量（token和uniId）导致meterMap里的key不重复，一直在插入，20万回调，token两小时更新一次，持续了两天，最终产生了124万条字符串，被map持有，无法回收。\n解决方案 不需要监控 直接排除掉spring-boot-starter-actuator\n需要监控但不需要http.client.request指标 management: metrics: web: client: request: autotime: enabled: false 需要http.client.request指标 jar包升到2.5.1或以上\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-actuator-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 复现： 新建测试项目\n相关代码和配置如下\n@SpringBootApplication @Slf4j public class Application { public static void main(String[] args) { ConfigurableApplicationContext run = SpringApplication.run(Application.class); RestTemplate bean = run.getBean(RestTemplate.class); for (int i = 0; i \u0026lt; 300000; i++) { try { String forObject = bean.getForObject(\u0026#34;http://localhost:9999/first/echo?i=\u0026#34;+i, String.class); }catch (Exception e){ log.error(\u0026#34;执行\u0026#34;+i+\u0026#34;次\u0026#34;); } } } } @Configuration public class RestTemplateTestConfig { @Bean public RestTemplate restTemplate(RestTemplateBuilder builder){ return builder.build(); } } \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.13.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; server: port: 8080 spring: redis: host: 101.43.164.254 password: hkc810215 #management: # endpoints: # web: # exposure: # include: \u0026#34;metrics\u0026#34; # metrics: # web: # client: # request: # autotime: # enabled: false 启动项目通过jconsole查看整个堆的监控和老年代监控分别如下，可以看出老年代一直在增长，并不会回收，\n甚至手动触发GC，老年代也回收不了\n[Full GC (System.gc()) [Tenured: 195217K-\u0026gt;195457K(204800K), 0.3975261 secs] 233021K-\u0026gt;195457K(296960K), [Metaspace: 30823K-\u0026gt;30823K(33152K)], 0.3976223 secs] [Times: user=0.39 sys=0.00, real=0.40 secs] 通过jprofiler确定主要是meterMap占据内存了，最多的都是字符串。\n分析 actuator导致rest启动了metrics记录 在使用RestTemplateBuilder构建RestTemplate的时候，会触发懒加载的RestTemplateAutoConfiguration里的RestTemplateBuilderConfigurer，在此期间，config中会注入RestTempalteCustomizer类型的bean。\n而项目中引用了redisson-spring-boot-starter，从依赖分析可以看出间接引用了actuator相关的包。\n这导致会在RestTemplateMetricsConfiguration配置类中实例化一个叫做MetricsRestTemplateCustomizer的bean，这个bean会通过上面的restTepalteBuilderConfigurer.configure方法给restTemplate添加拦截器MetricsClientHttpRequestInterceptor。\n拦截器的intercept方法会在finnally中最终记录此次请求的一些指标\nio.micrometer.core.instrument.Timer.Builder#register-\u0026gt;\nio.micrometer.core.instrument.MeterRegistry#time-\u0026gt;\nio.micrometer.core.instrument.MeterRegistry#registerMeterIfNecessary-\u0026gt;\nio.micrometer.core.instrument.MeterRegistry#getOrCreateMeter{\nmeterMap.put(mappedId, m);\n}\n最终存到了是SimpleMeterRegistry这个bean的meterMap中去，这个bean也是actuator-autoconfigure自动注入的\n但是到目前为止，只是启动了metrics记录，假如maxUriTags有效的话，会在超过100条记录后getOrCreateMeter方法里的accept这里过滤掉，并不会走到下面的meterMap.put(mappedId, m)\n为什么maxUriTags没有生效？ maxUriTags只在下图这个位置使用了，作用是构建了一个MeterFilter，根据debug我们可以确定bean是产生了的\n但是在accept这里打上断点，再触发一些请求可以发现，代码并不会走到这里\n往上跟，没有走到这里的情况只能是filters里没有这个MeterFilter，但我们刚才又确定metricsHttpCLientUriTagFilter这个bean是产生了的，那么就只能是没有添加到filters，也就是没有调用过meterFilter\n从meterFilter往上只有可能是addFilters，一层一层往上最终到了MeterRegistryPostProcessor#postProcessAfterInitialization这个方法\n我们上面说过负责记录的bean叫做simpleMeterRegistry，但是我们在这里打上条件断点发现并没有走到这里\n找到SimpleMeterRegistry和MeterRegistryPostProcessor这两个bean注入的地方打断点观察，都产生了，且MeterRegistryPostProcessor比SimpleMeterRegistry产生的要早\n理论上没问题，但现在确实没走到，所以只能在SimpleMeterRegistry产生的时候在org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization打断点，然后可以发现，在simpleMeterRegistry实例化快结束的时候，调用后处理器时this.beanPostProcessors确实没有MeterRegistryPostProcessor\n一般来说，postPorcessor的bean注入是在refresh方法的registerBeanPostProcessors中，是早于普通bean的实例化\n所以simpleMeterRegistry实例化的时候没有MeterRegistryPostProcessor是不合理的情况，定位simpleMeterRegistry是何时实例化的成了关键问题\nsimpleMeterRegistry的实例化时机 在new SimpleMeterRegistry这里打上断点观察堆栈发现，simpleMeterRegistry是MetricsRepositoryMethodInvocationListener的参数，MetricsRepositoryMethodInvocationListener则是metricsRepositoryMethodInvocationListenerBeanPostProcessor的参数\n所以是在实例化metricsRepositoryMethodInvocationListenerBeanPostProcessor这个处理器的时候，因为依赖导致先实例化了simpleMeterRegistry这个bean\n依赖，导致实例化了SimpleMeterRegistry，而这个时候由于没有注册，所以SimpleMeterRegistry在执行applyBeanPostProcessorsAfterInitialization时就执行不到meterRegistryPostProcessor了\nspring已经修复了这个问题，spring-boot-actuator-autoconfigure版本大于2.5.0的都已经没有问题了。解决方案\n2.5.1 版本中，添加了一个这个ObjectProvider，在源头上不会立即把依赖的bean初始化完\n2.5.0 版本\npublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set\u0026lt;String\u0026gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { descriptor.initParameterNameDiscovery(getParameterNameDiscoverer()); if (Optional.class == descriptor.getDependencyType()) { return createOptionalDependency(descriptor, requestingBeanName); } //由于使用了ObjectProvider，所以这里只是返回了一个DependencyObjectProvider else if (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) { return new DependencyObjectProvider(descriptor, requestingBeanName); } else if (javaxInjectProviderClass == descriptor.getDependencyType()) { return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName); } else { //2.5.0版本中会在这个方法加载入参依赖的bean Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary( descriptor, requestingBeanName); if (result == null) { result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter); } return result; } } "}