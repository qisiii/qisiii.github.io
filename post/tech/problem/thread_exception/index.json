{"title":"线程异常增长","permalink":"https://www.qisihub.cn/post/tech/problem/thread_exception/","date":"2023-08-18T00:00:00Z","content":"小组群内leader甩出来一个截图，说是线程有些异常，一直在增长，从pool-1-thread一直到pool-285-thread，每个pool都只有三个线程：thread-1 thread-2 thread-3，第一反应感觉肯定和定时任务有关，这种稳定的有规律的一般都是和定时任务有关。\n定位线程是哪部分的代码\n如果线程池自定义名字了，直接在项目里搜就可以\n直接查询最新的线程的日志，比如这里就是查询pool-285-thread对应的日志，如果有日志的话，很大概率就能直接定位到是哪里的问题，很不幸，我们出问题的这部分当时没有打印日志\n通过jstack分析\n分析代码\ntask(){ ExecutorService executorService = Executors.newFixedThreadPool(6); executorService.execute(()-\u0026gt;{统计1}) executorService.execute(()-\u0026gt;{统计2}) executorService.execute(()-\u0026gt;{统计3}) } 线上出问题的代码大概是上面的逻辑，根据现象我们知道，一共开启了285个线程池，线程池每次有三个线程在工作。\n为什么会开启这么多线程池？\n由于Executors.newFixedThreadPool(6)是放在类里面，且没有手动shutdown，导致每次定时任务执行这个方法的时候都会开启一个线程池\n为什么线程池里的线程没有回收？\nnewFixedThreadPool最大线程和核心线程数量是一样的，即这里创建了6个核心线程，而核心线程的回收又得手动指定allowCoreThreadTimeOut为true才可以，所以并不会被回收\npublic static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 复现验证 public class Case { void fixPoolInc() { ExecutorService executorService = Executors.newFixedThreadPool(6); for (int i = 0; i \u0026lt; 3; i++) { executorService.execute(() -\u0026gt; { System.out.println(\u0026#34;ThreadName:\u0026#34; + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }); } } @SneakyThrows public static void main(String[] args) { Case aCase = new Case(); for (int i = 0; i \u0026lt; 10; i++) { Thread.sleep(5000); aCase.fixPoolInc(); } } } 开10个线程池，每个线程池启动3个线程，通过jconsole观察是否线程持续增长，并没有回收\n结论\n方法内部开启的线程池记得手动关闭，或者将方法内部的线程池提到外部\n最好还是通过ThreadPoolExecutor手动设置每个参数，这样对于业务更清晰，而不是偷懒使用ExecutorService\n线程池最好还是指定明细，这边方便排查异常\n参考文档： Java线程Dump分析_线程dump怎么分析_萨达哈鲁君的博客-CSDN博客\nidea + jconsole实现线程监控_idea查看线程运行情况_黑夜伴白行的博客-CSDN博客\n深入浅出线:程池的线程回收\u0026ndash;回收的是非核心线程吗?_非核心线程的是怎么回收的_小猪快跑22的博客-CSDN博客\n"}