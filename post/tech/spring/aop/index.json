{"title":"Aop执行逻辑","permalink":"https://www.qisihub.cn/post/tech/spring/aop/","date":"2024-04-27T00:00:00Z","content":"AopAutoConfiguration 在spring-boot-autoconfiguration的spring.factories中指定了org.springframework.boot.autoconfigure.aop.AopAutoConfiguration这个bean，因此会进行执行\n@Configuration(proxyBeanMethods = false) //默认开启，如果不配或者为true都是开启，为false则是关闭 @ConditionalOnProperty(prefix = \u0026#34;spring.aop\u0026#34;, name = \u0026#34;auto\u0026#34;, havingValue = \u0026#34;true\u0026#34;, matchIfMissing = true) public class AopAutoConfiguration { //如果项目中引入aspectjweaver包，则实例化AspectJAutoProxyingConfiguration否则实例化ClassProxyingConfiguration @Configuration(proxyBeanMethods = false) @ConditionalOnClass(Advice.class) static class AspectJAutoProxyingConfiguration { @Configuration(proxyBeanMethods = false) @EnableAspectJAutoProxy(proxyTargetClass = false) @ConditionalOnProperty(prefix = \u0026#34;spring.aop\u0026#34;, name = \u0026#34;proxy-target-class\u0026#34;, havingValue = \u0026#34;false\u0026#34;) static class JdkDynamicAutoProxyConfiguration { } //默认启用的是cglib代理，通过@EnableAspectJAutoProxy引入其他类（EnableAspectJAutoProxy）的配置 @Configuration(proxyBeanMethods = false) @EnableAspectJAutoProxy(proxyTargetClass = true) @ConditionalOnProperty(prefix = \u0026#34;spring.aop\u0026#34;, name = \u0026#34;proxy-target-class\u0026#34;, havingValue = \u0026#34;true\u0026#34;, matchIfMissing = true) static class CglibAutoProxyConfiguration { } } @Configuration(proxyBeanMethods = false) @ConditionalOnMissingClass(\u0026#34;org.aspectj.weaver.Advice\u0026#34;) @ConditionalOnProperty(prefix = \u0026#34;spring.aop\u0026#34;, name = \u0026#34;proxy-target-class\u0026#34;, havingValue = \u0026#34;true\u0026#34;, matchIfMissing = true) static class ClassProxyingConfiguration { @Bean static BeanFactoryPostProcessor forceAutoProxyCreatorToUseClassProxying() { return (beanFactory) -\u0026gt; { if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry); //默认也是cglib AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } }; } } } AspectJAutoProxyingConfiguration和ClassProxyingConfiguration的区别在于\nClassProxyingConfiguration想要注册的是InfrastructureAdvisorAutoProxyCreator\nAspectJAutoProxyingConfiguration注册的则是AnnotationAwareAspectJAutoProxyCreator\n这里是不同级别的creator，总共存在三个，如果存在低级则替换成高级\nprivate static BeanDefinition registerOrEscalateApcAsRequired( Class\u0026lt;?\u0026gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) { Assert.notNull(registry, \u0026#34;BeanDefinitionRegistry must not be null\u0026#34;); if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) { BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME); if (!cls.getName().equals(apcDefinition.getBeanClassName())) { int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName()); int requiredPriority = findPriorityForClass(cls); //如果当前等级小于需要的等级，则改为高等级 if (currentPriority \u0026lt; requiredPriority) { apcDefinition.setBeanClassName(cls.getName()); } } return null; } RootBeanDefinition beanDefinition = new RootBeanDefinition(cls); beanDefinition.setSource(source); //这个顺序有啥用？ beanDefinition.getPropertyValues().add(\u0026#34;order\u0026#34;, Ordered.HIGHEST_PRECEDENCE); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition); return beanDefinition; } 这里先不熟悉三个creator的区别，有时间了搞，由于事务这里注册的是最高级别-AnnotationAwareAspectJAutoProxyCreator，所以先分析这个类\nAnnotationAwareAspectJAutoProxyCreator 观察类图\n这个类实现了BeanFactoryAware接口来获取beanFacotry\n实现了SmartInstantiationAwareBeanPostProcessor接口，主要重写了四个方法：predictBeanType、postProcessBeforeInstantiation、getEarlyBeanReference和postProcessAfterInstantiation，\npostProcessBeforeInstantiation主要是用于自定义了TargetSource的情况，但是没见在哪用过；\ngetEarlyBeanReference则适用于处理循环依赖的时候，核心方法是wrapIfNecessary\npostProcessAfterInstantiation则是正常的bean初始化结束后对bean进行aop增强的逻辑\n@Override public Object getEarlyBeanReference(Object bean, String beanName) { Object cacheKey = getCacheKey(bean.getClass(), beanName); this.earlyProxyReferences.put(cacheKey, bean); return wrapIfNecessary(bean, beanName, cacheKey); } @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (this.earlyProxyReferences.remove(cacheKey) != bean) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; } 增强流程 wrapIfNecessary protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { if (StringUtils.hasLength(beanName) \u0026amp;\u0026amp; this.targetSourcedBeans.contains(beanName)) { return bean; } //已经存在表示这个bean处理过了 if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } //Advice、Pointcut、Advisor、AopInfrastructureBean为基础架构类，永远不可被代理 //Q\u0026amp;A 2024/4/27 // Q:shouldSkip里逻辑不懂,而且isInfrastructureClass排除了Advisor.class.isAssignableFrom(beanClass)，但实际上查询Advicors的时候又找的这个类型的bean，这怎么搞 // A: if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } // Create proxy if we have advice. // async最大的问题就是这里没有扫描到 //获取所有匹配的Advisor,是排好序的 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); //进行增强 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } protected List\u0026lt;Advisor\u0026gt; findEligibleAdvisors(Class\u0026lt;?\u0026gt; beanClass, String beanName) { //先查找所有的候选Advisor List\u0026lt;Advisor\u0026gt; candidateAdvisors = findCandidateAdvisors(); //进行匹配 List\u0026lt;Advisor\u0026gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); //追加了一个ExposeInvocationInterceptor.ADVISOR extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) { //进行排序 //默认是AnnotationAwareOrderComparator.sort(advisors)；但是AspectJAwareAdvisorAutoProxyCreator重写了排序逻辑 eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors; } findCandidateAdvisors findCandidateAdvisors有两种，一种是继承了Advisor接口的bean（通过beanFactory直接查询），一种是标有@Aspect的（需要扫描所有的bean，然后反射获取切面所有的方法，每个方法单独封装为一个Advisor\npublic List\u0026lt;Advisor\u0026gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) { Class\u0026lt;?\u0026gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName(); validate(aspectClass); // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator // so that it will only instantiate once. MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory = new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory); List\u0026lt;Advisor\u0026gt; advisors = new ArrayList\u0026lt;\u0026gt;(); //获取所有类的方法并排序，按照注解排序Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class)-\u0026gt;按照方法名排序 for (Method method : getAdvisorMethods(aspectClass)) { //获取切面-将pointCut和Advice组装起来 Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, 0, aspectName); if (advisor != null) { advisors.add(advisor); } } //这个是introduction机制，需要使用@DeclareParents注解 for (Field field : aspectClass.getDeclaredFields()) { Advisor advisor = getDeclareParentsAdvisor(field); if (advisor != null) { advisors.add(advisor); } } ... } private List\u0026lt;Method\u0026gt; getAdvisorMethods(Class\u0026lt;?\u0026gt; aspectClass) { List\u0026lt;Method\u0026gt; methods = new ArrayList\u0026lt;\u0026gt;(); ReflectionUtils.doWithMethods(aspectClass, methods::add, adviceMethodFilter); if (methods.size() \u0026gt; 1) { methods.sort(adviceMethodComparator); } return methods; } //先按照注解排序，再按照方法名称排序 Comparator\u0026lt;Method\u0026gt; adviceKindComparator = new ConvertingComparator\u0026lt;\u0026gt;( new InstanceComparator\u0026lt;\u0026gt;( Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class), (Converter\u0026lt;Method, Annotation\u0026gt;) method -\u0026gt; { AspectJAnnotation\u0026lt;?\u0026gt; ann = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method); return (ann != null ? ann.getAnnotation() : null); }); Comparator\u0026lt;Method\u0026gt; methodNameComparator = new ConvertingComparator\u0026lt;\u0026gt;(Method::getName); adviceMethodComparator = adviceKindComparator.thenComparing(methodNameComparator); 获取Advisor public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrderInAspect, String aspectName) { validate(aspectInstanceFactory.getAspectMetadata().getAspectClass()); //切点其实封装的就是表达式和切面类 AspectJExpressionPointcut expressionPointcut = getPointcut( candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass()); if (expressionPointcut == null) { return null; } //封装切点和Advice，advice其实就是那几种注解@Before、@After之类的 return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod, this, aspectInstanceFactory, declarationOrderInAspect, aspectName); } 获取切点 private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class\u0026lt;?\u0026gt; candidateAspectClass) { AspectJAnnotation\u0026lt;?\u0026gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) { return null; } AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class\u0026lt;?\u0026gt;[0]); //将方法上的注解的value值放到expression属性 ajexp.setExpression(aspectJAnnotation.getPointcutExpression()); if (this.beanFactory != null) { ajexp.setBeanFactory(this.beanFactory); } return ajexp; } 获取Advice public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) { .... //主要就这几种场景的advice switch (aspectJAnnotation.getAnnotationType()) { case AtPointcut: if (logger.isDebugEnabled()) { logger.debug(\u0026#34;Processing pointcut \u0026#39;\u0026#34; + candidateAdviceMethod.getName() + \u0026#34;\u0026#39;\u0026#34;); } return null; case AtAround: springAdvice = new AspectJAroundAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtBefore: springAdvice = new AspectJMethodBeforeAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfter: springAdvice = new AspectJAfterAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfterReturning: springAdvice = new AspectJAfterReturningAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterReturningAnnotation.returning())) { springAdvice.setReturningName(afterReturningAnnotation.returning()); } break; case AtAfterThrowing: springAdvice = new AspectJAfterThrowingAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterThrowingAnnotation.throwing())) { springAdvice.setThrowingName(afterThrowingAnnotation.throwing()); } break; default: throw new UnsupportedOperationException( \u0026#34;Unsupported advice type on method: \u0026#34; + candidateAdviceMethod); } Advisor排序逻辑 默认是AnnotationAwareOrderComparator.sort(advisors)；但是AspectJAwareAdvisorAutoProxyCreator重写了排序逻辑\nAnnotationAwareOrderComparator 这个类实现了OrderComparator，正常对于OrderComparator来说，其compare调用doCompare，里面的顺序以getOrder方法为主，getOrder调用的又是findOrder，及根据接口Ordered.getOrder获取顺序值\nprivate int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) { boolean p1 = (o1 instanceof PriorityOrdered); boolean p2 = (o2 instanceof PriorityOrdered); if (p1 \u0026amp;\u0026amp; !p2) { return -1; } else if (p2 \u0026amp;\u0026amp; !p1) { return 1; } int i1 = getOrder(o1, sourceProvider); int i2 = getOrder(o2, sourceProvider); return Integer.compare(i1, i2); } protected Integer findOrder(Object obj) { return (obj instanceof Ordered ? ((Ordered) obj).getOrder() : null); } 而AnnotationAwareOrderComparator则进行了扩展，对于使用了@Order注解的也可以做排序，主要是重写了findOrder方法\nprotected Integer findOrder(Object obj) { Integer order = super.findOrder(obj); if (order != null) { return order; } return findOrderFromAnnotation(obj); } @Nullable private Integer findOrderFromAnnotation(Object obj) { AnnotatedElement element = (obj instanceof AnnotatedElement ? (AnnotatedElement) obj : obj.getClass()); MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY); Integer order = OrderUtils.getOrderFromAnnotations(element, annotations); if (order == null \u0026amp;\u0026amp; obj instanceof DecoratingProxy) { return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass()); } return order; } org.springframework.core.annotation.OrderUtils#findOrder private static Integer findOrder(MergedAnnotations annotations) { MergedAnnotation\u0026lt;Order\u0026gt; orderAnnotation = annotations.get(Order.class); if (orderAnnotation.isPresent()) { return orderAnnotation.getInt(MergedAnnotation.VALUE); } MergedAnnotation\u0026lt;?\u0026gt; priorityAnnotation = annotations.get(JAVAX_PRIORITY_ANNOTATION); if (priorityAnnotation.isPresent()) { return priorityAnnotation.getInt(MergedAnnotation.VALUE); } return null; } AspectJAwareAdvisorAutoProxyCreator.sort protected List\u0026lt;Advisor\u0026gt; sortAdvisors(List\u0026lt;Advisor\u0026gt; advisors) { List\u0026lt;PartiallyComparableAdvisorHolder\u0026gt; partiallyComparableAdvisors = new ArrayList\u0026lt;\u0026gt;(advisors.size()); for (Advisor advisor : advisors) { partiallyComparableAdvisors.add( new PartiallyComparableAdvisorHolder(advisor, DEFAULT_PRECEDENCE_COMPARATOR)); } List\u0026lt;PartiallyComparableAdvisorHolder\u0026gt; sorted = PartialOrder.sort(partiallyComparableAdvisors); if (sorted != null) { List\u0026lt;Advisor\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(advisors.size()); for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) { result.add(pcAdvisor.getAdvisor()); } return result; } else { return super.sortAdvisors(advisors); } } private static final Comparator\u0026lt;Advisor\u0026gt; DEFAULT_PRECEDENCE_COMPARATOR = new AspectJPrecedenceComparator(); 先梳理一下陌生的类\nPartiallyComparableAdvisorHolder：持有Advisor和一个Comparator，重写了compareTo和fallbackCompareTo\nprivate static class PartiallyComparableAdvisorHolder implements PartialComparable { private final Advisor advisor; private final Comparator\u0026lt;Advisor\u0026gt; comparator; public PartiallyComparableAdvisorHolder(Advisor advisor, Comparator\u0026lt;Advisor\u0026gt; comparator) { this.advisor = advisor; this.comparator = comparator; } @Override public int compareTo(Object obj) { Advisor otherAdvisor = ((PartiallyComparableAdvisorHolder) obj).advisor; return this.comparator.compare(this.advisor, otherAdvisor); } @Override public int fallbackCompareTo(Object obj) { return 0; } AspectJPrecedenceComparator：默认还是AnnotationAwareOrderComparator，但是对于同一个切面的advisor做了自己的处理。但是在spring 5.2.7 之前是有用的，5.2.7之后，declarationOrderInAspect全部强制改为0了\n// Prior to Spring Framework 5.2.7, advisors.size() was supplied as the declarationOrderInAspect\n// to getAdvisor(\u0026hellip;) to represent the \u0026ldquo;current position\u0026rdquo; in the declared methods list.\n// However, since Java 7 the \u0026ldquo;current position\u0026rdquo; is not valid since the JDK no longer\n// returns declared methods in the order in which they are declared in the source code.\n// Thus, we now hard code the declarationOrderInAspect to 0 for all advice methods\n// discovered via reflection in order to support reliable advice ordering across JVM launches.\n// Specifically, a value of 0 aligns with the default value used in\n// AspectJPrecedenceComparator.getAspectDeclarationOrder(Advisor).\npublic AspectJPrecedenceComparator() { this.advisorComparator = AnnotationAwareOrderComparator.INSTANCE; } public int compare(Advisor o1, Advisor o2) { //即先拿order比较 int advisorPrecedence = this.advisorComparator.compare(o1, o2); if (advisorPrecedence == SAME_PRECEDENCE \u0026amp;\u0026amp; declaredInSameAspect(o1, o2)) { advisorPrecedence = comparePrecedenceWithinAspect(o1, o2); } return advisorPrecedence; } //拿声明顺序比较 private int comparePrecedenceWithinAspect(Advisor advisor1, Advisor advisor2) { boolean oneOrOtherIsAfterAdvice = (AspectJAopUtils.isAfterAdvice(advisor1) || AspectJAopUtils.isAfterAdvice(advisor2)); int adviceDeclarationOrderDelta = getAspectDeclarationOrder(advisor1) - getAspectDeclarationOrder(advisor2); //对于是否存在after，是两种逻辑，存在after的话，最后声明的有最高优先级，否则，最先声明的有最高优先级 //Q\u0026amp;A 2024/4/27 // Q: 完全不理解 // A: if (oneOrOtherIsAfterAdvice) { // the advice declared last has higher precedence if (adviceDeclarationOrderDelta \u0026lt; 0) { // advice1 was declared before advice2 // so advice1 has lower precedence return LOWER_PRECEDENCE; } else if (adviceDeclarationOrderDelta == 0) { return SAME_PRECEDENCE; } else { return HIGHER_PRECEDENCE; } } else { // the advice declared first has higher precedence if (adviceDeclarationOrderDelta \u0026lt; 0) { // advice1 was declared before advice2 // so advice1 has higher precedence return HIGHER_PRECEDENCE; } else if (adviceDeclarationOrderDelta == 0) { return SAME_PRECEDENCE; } else { return LOWER_PRECEDENCE; } } } 此外，这里使用的不是TimSort，而是PartialOrder(离散里的偏序）\n"}