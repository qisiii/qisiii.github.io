<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mysql on 起司的博客</title><link>https://blog.qisiii.asia/tags/mysql/</link><description>Recent content in Mysql on 起司的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>起司</copyright><lastBuildDate>Sat, 30 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.qisiii.asia/tags/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>UndoLog和redoLog</title><link>https://blog.qisiii.asia/post/tech/mysql/undolog_redolog/</link><pubDate>Sat, 30 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.qisiii.asia/post/tech/mysql/undolog_redolog/</guid><description>&lt;h2 id="redolog">redolog
&lt;/h2>&lt;p>从ACID了解到，对于数据库来说，原子性和持久性是为了保证数据修改之后就不会再有变换，但是持久性这个动作不是一个原子性的操作，包含写入、未写入和正在写多个状态。&lt;/p>
&lt;p>假如是未提交事务（内存操作），这个时候就将数据落盘，那么这个时候如果崩溃了，在恢复数据的时候，就要将落盘的数据修改为未提交事务之前的数据。&lt;/p>
&lt;p>假如是提交事务了（内存操作），这个时候数据还没有落盘，这个时候如果崩溃，就要在磁盘补充所落下的部分。&lt;/p>
&lt;p>因此，不能将写入磁盘作为一个简单的动作看待，目前通用的方案是通过日志顺序写入，在提交事务后，日志追加Commit record语句，然后开始写入磁盘，当完全写入之后，追加End record语句，这种方案被称为Commit Log，这个日志被称为redo Log.&lt;/p>
&lt;p>至此redolog其实是为了解耦内存和硬盘的一致性，那核心原因是什么呢？&lt;/p>
&lt;p>就在于顺序IO和随机IO的不同&lt;/p>
&lt;h2 id="undolog">undolog
&lt;/h2>&lt;p>但是这样存在的问题就是，写入磁盘的动作一定是在提交事务（日志写入Commit record）之后，这样子无法利用可能空闲的磁盘IO，这样对数据库的性能有一定的影响。&lt;/p>
&lt;p>因此，ARIES理论提出了一个 write-head logging（提前写入)的方案，他将根据事务提交前后分为不同的状态。&lt;/p>
&lt;p>Force：事务提交后就一定要落入磁盘。&lt;/p>
&lt;p>NoForce: 事务提交后不一定要立即落入磁盘。因为有了日志，随时可以落入磁盘。&lt;/p>
&lt;p>STEAL：事务在提交前，允许数据提前写入。&lt;/p>
&lt;p>NOSTEAL：事务在提交前，不允许数据提前写入。&lt;/p>
&lt;p>像上面的Commit Log，就是属于 NotForce-NoSteal，这是因为假如事务提交前，数据已经提前写入，这个时候崩溃了的话，恢复的时候，不知道恢复成什么样子。&lt;/p>
&lt;p>因此，为了可以提前写入数据，崩溃时为了知道恢复成什么样子，就需要另一个日志来保证恢复数据，这个日志记录要记录各个版本的数据。这个日志就是undolog。&lt;/p>
&lt;p>这样子的话，崩溃恢复的时候，就会经历三个阶段&lt;/p>
&lt;p>分析：找到所有没有end record的事务&lt;/p>
&lt;p>重做：将所有有Commit record的数据落入磁盘，并追加end record&lt;/p>
&lt;p>回滚：将经历过上两个状态的剩余的事务，即没有Commit record的数据，根据undolog进行回滚。&lt;/p>
&lt;p>&lt;img src="http://picgo.qisiii.asia/post/11-16-54-37-image.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="redolog和binlog的同步问题">redolog和binlog的同步问题
&lt;/h2>&lt;p>redolog分析过了，主要是实现事务的原子性；&lt;/p>
&lt;p>由binlog可知，其内部也会记录事务相关的数据，主要用于恢复和主从中，那么redolog和binlog以谁为准呢？先写redolog还是binlog呢？&lt;/p>
&lt;p>假如先写redolog，那么在binlog写入之前crash的话，主库会由这个事务的更新记录，从库因为binlog中没有，所以主从不一致。&lt;/p>
&lt;p>假如先写binlog，在写redolog中发生crash，那么则是从库由，主库没有。&lt;/p>
&lt;p>因此，对于这个问题，不能简单的采用先后来完成，而是采用XA的两段式提交方案，&lt;/p>
&lt;p>先写redolog，此时redolog是prepare状态；然后写binlog（write/fsync)，在binlog写完之后，redolog追加commit标志事务提交。&lt;/p>
&lt;p>换句话说，就是将redolog和binlog视作不同的资源，只有两个资源都准备完成的时候，才进行提交，否则就进行回滚。&lt;/p>
&lt;p>而整体是以binlog为基准的&lt;/p>
&lt;p>当redolog在做的时候crash的话，由于此时事务还未提交，binlog中也没有，所以直接回滚即可，数据是一致的。&lt;/p>
&lt;p>当redolog做完，在写binlog的时候crash的话，binlog中也没有，因此还是回滚。&lt;/p>
&lt;p>当binlog写完的时候，crash的话，由于binlog中存在，已找到最新的事务id，然后在redolog重做，没有commit record的要追加commit record；&lt;/p>
&lt;p>但是这里的前提是，开始了binlog，因为binlog 是有可能不开启的。&lt;/p>
&lt;p>&lt;img src="http://picgo.qisiii.asia/post/11-16-55-12-image.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="关于xa提交时引发的性能问题">关于XA提交时引发的性能问题？
&lt;/h2>&lt;p>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/98791003" target="_blank" rel="noopener"
>XA协议binlog 和 redo log的一致性问题&lt;/a>&lt;/p>
&lt;h1 id="参考文档">参考文档：
&lt;/h1>&lt;p>&lt;a class="link" href="https://time.geekbang.org/column/article/319481" target="_blank" rel="noopener"
>11 | 本地事务如何实现原子性和持久性？-极客时间&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://time.geekbang.org/column/article/68633" target="_blank" rel="noopener"
>02 | 日志系统：一条SQL更新语句是如何执行的？-极客时间&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/huangjw_806/article/details/100927097" target="_blank" rel="noopener"
>MySQL中binlog和redo log的一致性问题_binlog 和 redo不同步-CSDN博客&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://time.geekbang.org/column/article/76161" target="_blank" rel="noopener"
>23 | MySQL是怎么保证数据不丢的？-极客时间&lt;/a>&lt;/p></description></item><item><title>锁</title><link>https://blog.qisiii.asia/post/tech/mysql/db_lock/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.qisiii.asia/post/tech/mysql/db_lock/</guid><description>&lt;h2 id="mvcc机制遗留的问题">MVCC机制遗留的问题
&lt;/h2>&lt;p>&lt;strong>为什么在可重复读级别下，幻读没有产生？&lt;/strong>&lt;/p>
&lt;p>回想一下在事务隔离级别那篇文章中，可串行化是通过什么保证的？&lt;/p>
&lt;p>对操作的每一行记录加读锁、写锁和范围锁；任何其他事务都必须等待持有锁的事务释放锁之后才能进行操作；&lt;/p>
&lt;p>而可重复读级别相比之下唯一少的就是范围锁，所以无论你是否了解过具体原因，都应该去猜测推理，大概率是加了范围锁。而在这里，他有一个特殊的名字，叫做间隙锁。&lt;/p>
&lt;p>虽然我很想直接上间隙锁相关的内容，但是为了更加有体系化，最好还是完整梳理一下；&lt;/p>
&lt;p>本篇文章最好是有一点基础再看，因为本身就是自记录，没有打算写一篇完整的教学博客。&lt;/p>
&lt;h2 id="读锁和写锁共享锁和排它锁">读锁和写锁（共享锁和排它锁）
&lt;/h2>&lt;p>Shared Lock 共享锁（S锁），也叫读锁；不和读锁冲突，但和写锁冲突；&lt;/p>
&lt;p>当事务A持有读锁的时候，事务B依然可以加读锁；但是除了事务A自己可以加写锁，其他事务都无法对这条记录加写锁。&lt;/p>
&lt;p>Exclusive Lock 排他锁（X锁），也叫写锁；和谁都冲突；&lt;/p>
&lt;p>即当事务A持有记录的写锁时，其他事务读锁和写锁都加不了&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>S&lt;/td>
&lt;td>X&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S&lt;/td>
&lt;td>兼容&lt;/td>
&lt;td>冲突&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X&lt;/td>
&lt;td>冲突&lt;/td>
&lt;td>冲突&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>行和列代表不同事务&lt;/p>
&lt;/blockquote>
&lt;h2 id="表锁">表锁
&lt;/h2>&lt;h3 id="表锁-1">表锁
&lt;/h3>&lt;h4 id="上锁和解锁">上锁和解锁
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Bash" data-lang="Bash">&lt;span class="line">&lt;span class="cl">lock tables 表名 &lt;span class="o">[&lt;/span>as alisa&lt;span class="o">]&lt;/span> 锁类型&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">unlock tables &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>表锁的命令就是上述两行，且表锁也分读写锁，表级读写的兼容冲突和读写锁一致。&lt;/p>
&lt;p>通过lock tables 命令加锁的session，在释放锁之前，能且只能执行lock tables 命令后面指定的表，命令类型和锁类型保持一致；比如 lock tables A read,那么后面就只能读A表，而不能执行读B表，或者写A表；如下面的例子一样；另外如果使用了别名，那么需要确保查询语句涉及的别名和lock table的别名完全一致；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">lock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">simple&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">read&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">simple&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">batch_insert&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">HY000&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">1100&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;batch_insert&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">was&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">locked&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">with&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LOCK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TABLES&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">simple&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">Table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;simple&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">was&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">locked&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">with&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">READ&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">lock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">can&lt;/span>&lt;span class="s1">&amp;#39;t be updated
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Unlock tables 会显式的释放所有该session之前加的所有表；另一个作用是释放&lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/flush.html#flush-tables-with-read-lock">FLUSH TABLES WITH READ LOCK&lt;/a>&lt;/code>&lt;/u>&lt;u>命令所加的全局读锁；&lt;/u>&lt;/p>
&lt;blockquote>
&lt;p>Another use for &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">UNLOCK TABLES&lt;/a>&lt;/code>&lt;/u> is to release the global read lock acquired with the &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/flush.html#flush-tables-with-read-lock">FLUSH TABLES WITH READ LOCK&lt;/a>&lt;/code>&lt;/u> statement, which enables you to lock all tables in all databases. See &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/flush.html" target="_blank" rel="noopener"
>Section 13.7.8.3, “FLUSH Statement”&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>lock tables、start transcation命令可以隐式的释放之前持有的锁；&lt;/p>
&lt;h4 id="查看锁情况">查看锁情况
&lt;/h4>&lt;p>可通过下面的命令查看表是否上锁，name_locked为0表示上锁&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">show&lt;/span> &lt;span class="n">OPEN&lt;/span> &lt;span class="n">TABLES&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">In_use&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjVlMjQyZTVjMTYxZmZjZjRkOTg0MjkwMmQyM2VhMGRfWUJBZE5IMnFlUzJtbnZTU3FRMHhYNGRmUWhxYlduZzlfVG9rZW46UU1yY2IyWmJPb0xmdjd4cko5b2NGQ1hubmtiXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>WRITE&lt;/code> locks normally have higher priority than &lt;code>READ&lt;/code> locks to ensure that updates are processed as soon as possible. This means that if one session obtains a &lt;code>READ&lt;/code> lock and then another session requests a &lt;code>WRITE&lt;/code> lock, subsequent &lt;code>READ&lt;/code> lock requests wait until the session that requested the &lt;code>WRITE&lt;/code> lock has obtained the lock and released it.&lt;/p>
&lt;/blockquote>
&lt;p>对于读-写-读的情况，由于锁的优先级较高，如果申请写的session迟迟获取不到锁，会阻塞后续其他session申请读锁；具体分析看Case1；&lt;/p>
&lt;h3 id="全局读锁">全局读锁
&lt;/h3>&lt;p>关于全局锁，我一共只在两篇文档中看到过；一个是《Mysql45讲》的06篇，一个mysql官方文档的lock-table文章和FLUSH Statement文章，所以了解的并不全，加上此时的我还不太关心数据库主从的问题，所以也没有深入研究。&lt;/p>
&lt;p>&lt;strong>FLUSH TABLES WITH READ LOCK&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>Closes all open tables and locks all tables for all databases with a global read lock.&lt;/p>
&lt;/blockquote>
&lt;h3 id="元数据锁">元数据锁
&lt;/h3>&lt;blockquote>
&lt;p>Statements acquire metadata locks one by one, not simultaneously, and perform deadlock detection in the process.&lt;/p>
&lt;p>DML statements normally acquire locks in the order in which tables are mentioned in the statement.&lt;/p>
&lt;p>DDL statements, &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">LOCK TABLES&lt;/a>&lt;/code>&lt;/u>, and other similar statements try to reduce the number of possible deadlocks between concurrent DDL statements by acquiring locks on explicitly named tables in name order.&lt;/p>
&lt;/blockquote>
&lt;p>元数据锁是一个个获取的，DML和DDL通过不同的方式定义执行的顺序；官网提供了一个rename table的顺序例子，但那个例子挺迷的；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//可以通过这个表查看元数据锁的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">metadata_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>To ensure transaction serializability, the server must not permit one session to perform a data definition language (DDL) statement on a table that is used in an uncompleted explicitly or implicitly started transaction in another session. The server achieves this by acquiring metadata locks on tables used within a transaction and deferring release of those locks until the transaction ends. A metadata lock on a table prevents changes to the table&amp;rsquo;s structure. This locking approach has the implication that a table that is being used by a transaction within one session cannot be used in DDL statements by other sessions until the transaction ends.&lt;/p>
&lt;/blockquote>
&lt;p>如果一个session或者一个事务持有某个表的元数据锁，那么另一个session或者事务就无法执行DDL操作；&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html&lt;/a>&lt;/p>
&lt;h4 id="读写阻塞问题">读写阻塞问题
&lt;/h4>&lt;p>关于元数据锁，在《Mysql45讲》中有提到一个问题，后加的读锁会被前面的写锁所阻塞，很类似于表锁最后提到的优先级问题，有没有可能是一个原因呢？具体见case2&lt;/p>
&lt;h2 id="行锁record-lock">行锁（Record Lock)
&lt;/h2>&lt;blockquote>
&lt;p>A record lock is a lock on an index record.&lt;/p>
&lt;/blockquote>
&lt;p>行锁是在索引上的一个锁。这句话非常重要！&lt;/p>
&lt;p>这里的索引可以是聚簇索引也可以是二级索引，如果表中没有索引或者查询的条件没有索引，又或者优化器认为索引没有作用，这个时候就会退化为“表锁”，但我总感觉像是锁定了所有行。&lt;/p>
&lt;p>另外，如果表中没有定义聚簇索引，会自动生成一个隐藏的索引。&lt;/p>
&lt;h3 id="间隙锁gap-lock">间隙锁（Gap Lock）
&lt;/h3>&lt;blockquote>
&lt;p>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.&lt;/p>
&lt;/blockquote>
&lt;p>单靠行锁是无法解决幻读的问题的，所以innodb引入了间隙锁的概念，只在RR级别生效。间隙锁是一个范围锁，比如所以索引1和索引3之间就存在（1，3）这样一个间隙，当这个间隙被锁定的时候，就无法插入值为2的记录。&lt;/p>
&lt;p>不同的事务对于同一个间隙加锁是允许发生的，因为都是在保护这个间隙不被插入数据。&lt;/p>
&lt;blockquote>
&lt;p>Gap locking is not needed for statements that lock rows using a unique index to search for a unique row.&lt;/p>
&lt;/blockquote>
&lt;p>当查询条件是唯一索引，如果查询的值存在且是唯一的一行记录，那么是不需要加间隙锁的；因为间隙锁的出现就是为了防止幻读，对于加了唯一索引的表，同样的查询条件永远只能查出唯一的一条，既然已经保证了唯一，那么就没有间隙锁的必要了。&lt;/p>
&lt;p>那如果查询结果不存在？以及查询条件是范围查询？又或者是普通索引甚至没有索引呢？&lt;/p>
&lt;p>关于这些情况的排列组合，见case3&lt;/p>
&lt;h3 id="临键锁next-key-lock">临键锁(next-key Lock)
&lt;/h3>&lt;blockquote>
&lt;p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.&lt;/p>
&lt;/blockquote>
&lt;p>临建锁=行锁+间隙锁，是innodb RR级别默认加的锁；由于锁定的是当前索引记录行和索引前的部分，所以一般总结为左开右闭；&lt;/p>
&lt;p>假如存在索引10,11,13,20，那么就会存在以下几个区间，最后一个范围是mysql会假定一个非常大的supremum，但由于实际并不存在这个值，所以是左开右开。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="n">negative&lt;/span> &lt;span class="n">infinity&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">positive&lt;/span> &lt;span class="n">infinity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="意向锁">意向锁
&lt;/h2>&lt;h3 id="表意向锁">表意向锁
&lt;/h3>&lt;p>innodb支持多粒度锁，即允许行锁和表锁同时存在，并且在加锁的时候需要进行冲突检测；&lt;/p>
&lt;p>比如事务A已经持有了a表的一条记录索引的行锁，这个时候B事务想要给a表加表锁，就需要一行行查看是否存在行锁；为了优化这种情况，innodb引入了意向锁的概念。&lt;/p>
&lt;p>表意向锁是个表级锁，分为读意向锁（IS）和写意向锁（IX），它们添加的时机是在对行索引添加S锁和X锁之前；即如果想要对某一行加锁，就必须先取得这个表的意向锁。这样当另一个事务需要判断时，就不需要一行行进行检查，只需要查看这个表是否具有意向锁即可。&lt;/p>
&lt;p>意向锁的作用主要是用来阻塞表锁的。所以其互相之间是不存在互斥的，只和表锁存在冲突，即读写冲突，具体就像是下面表格这样；&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>IX&lt;/td>
&lt;td>S&lt;/td>
&lt;td>IS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IX&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Compatible&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Compatible&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Compatible&lt;/td>
&lt;td>Compatible&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IS&lt;/td>
&lt;td>Conflict&lt;/td>
&lt;td>Compatible&lt;/td>
&lt;td>Compatible&lt;/td>
&lt;td>Compatible&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="插入意向锁">插入意向锁
&lt;/h3>&lt;blockquote>
&lt;p>An insert intention lock is a type of gap lock set by &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html">INSERT&lt;/a>&lt;/code>&lt;/u> operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.&lt;/p>
&lt;/blockquote>
&lt;p>插入意向锁是间隙锁类型的一种意向锁，锁的是间隙；是在进行插入之前必须申请获得的锁，所以和间隙锁是冲突的；换句话说，如果你想插入一条语句，那么这个语句对应的间隙必须不存在锁，这样你才能加上插入意向锁，进而插入数据；&lt;/p>
&lt;p>而且，插入意向锁只要插入的不是同一行，那么就可以同时插入；&lt;/p>
&lt;h2 id="自增锁auto-inc-locks">自增锁（&lt;strong>AUTO-INC Locks&lt;/strong>）
&lt;/h2>&lt;blockquote>
&lt;p>An &lt;code>AUTO-INC&lt;/code> lock is a special table-level lock taken by transactions inserting into tables with &lt;code>AUTO_INCREMENT&lt;/code> columns.&lt;/p>
&lt;/blockquote>
&lt;p>如官方文档所说，自增锁其实是只针对于自增的字段，算是一个表级锁，一般对我们来说就是自增主键；当有多个事务同时想要插入，由于自增的值必须保持连续，所以多个事务的插入必须串行；&lt;/p>
&lt;h2 id="case">Case
&lt;/h2>&lt;h3 id="case1表锁的读-写-读阻塞">case1（表锁的读-写-读阻塞）
&lt;/h3>&lt;p>先看正常情况，表锁的读锁是可以加多个的，如下，通过两个查询命令也可以看到确实同时加上了，没有阻塞；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">lock&lt;/span> &lt;span class="n">tables&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">lock&lt;/span> &lt;span class="n">tables&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>select * from performance_schema.metadata_locks;&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI1YTQ5NzUxMGNjOGY5YWFkZWRkNDM2NDFmMWRiODFfbmRvTXhUZDcwQXFRQlE1cU0yZFcyVU5Xdm9EN0dRdUxfVG9rZW46RGpTRmI2RTBCbzl5Rjh4Zm1NUGNGeThPbjVkXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>show OPEN TABLES where In_use &amp;gt; 0;&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzU5Y2Y3OTU0NWE2ZDY4MjU5NGI5NzA5ZTIwN2M1YzRfN2IwZkNnRHBjRjBxdVNoZk9CT2JBeFJrT2ZLVjNDaUpfVG9rZW46TmN3RmI2U1NGb1FxV3F4cnkzMWNxdVRRbndiXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>但是在两次读中间插入一次写锁的获取，后面的读锁也会同时被阻塞&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">lock&lt;/span> &lt;span class="n">tables&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">lock&lt;/span> &lt;span class="n">tables&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">write&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//被console1阻塞
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">lock&lt;/span> &lt;span class="n">tables&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//被console2阻塞
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实验证明确实如文档所说，但暂时没有分析原理；&lt;/p>
&lt;h3 id="case2元数据锁读-写-读">case2（元数据锁读-写-读）
&lt;/h3>&lt;p>mysql45讲中提到的一个问题，具体分析见&lt;a class="link" href="https://blog.csdn.net/q2878948/article/details/96430129" target="_blank" rel="noopener"
>mysql MDL读写锁阻塞，以及online ddl造成的“插队”现象_花落的速度的博客-CSDN博客&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdlM2FlODBlMWJjYWVhZjY4MWZjNzk4NTMxNTg5NzRfUW05R1ZYTHU5S0d4Z3IzMk9mRlJucTg3cTZWTEp3aFVfVG9rZW46SlNwaWJQcU1Vb1U1V0x4RnZEYWNmVGM0bmxlXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h3 id="case3next-key-lock-和-primary-key">case3(next-key lock 和 primary key)
&lt;/h3>&lt;p>在分析之前，先贴一下45讲的总结,该总结版本是 5.x 系列 &amp;lt;=5.7.24，8.0 系列 &amp;lt;=8.0.13，而我测试的版本是8.0.33&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQyZTgzN2FmMGU1ZDliYzE3ZGIzMDVhZjllNzE4NGRfcHYzWUdkb3paNUtJOERDNTQ1MExxU2NNd2g5aExEcHVfVG9rZW46WUVIMWI1bUFIb2daRkN4ZlI3MGM4TFZabkxmXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。&lt;/p>
&lt;p>原则 2：查找过程中访问到的对象才会加锁。&lt;/p>
&lt;p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。&lt;/p>
&lt;p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。&lt;/p>
&lt;p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。&lt;/p>
&lt;/blockquote>
&lt;p>目前的数据&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">CREATE&lt;/span> &lt;span class="n">TABLE&lt;/span> &lt;span class="err">`&lt;/span>&lt;span class="n">simple&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">bigint&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">AUTO_INCREMENT&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;主键&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="nf">varchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">256&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">COLLATE&lt;/span> &lt;span class="n">utf8mb4_bin&lt;/span> &lt;span class="n">DEFAULT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;字符&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">seq&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">bigint&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;消息序号&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">tinyint&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;类型，&lt;/span>&lt;span class="n">tinyint值&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">version&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">DEFAULT&lt;/span> &lt;span class="sc">&amp;#39;1&amp;#39;&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;版本值&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">text&lt;/span> &lt;span class="n">COLLATE&lt;/span> &lt;span class="n">utf8mb4_bin&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;消息&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">create_time&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">datetime&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">DEFAULT&lt;/span> &lt;span class="n">CURRENT_TIMESTAMP&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;创建时间&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">update_time&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">datetime&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">DEFAULT&lt;/span> &lt;span class="n">CURRENT_TIMESTAMP&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;修改时间&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">yn&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">tinyint&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">DEFAULT&lt;/span> &lt;span class="sc">&amp;#39;1&amp;#39;&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;是否有效&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">`&lt;/span>&lt;span class="n">uni&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">NOT&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="n">COMMENT&lt;/span> &lt;span class="err">&amp;#39;唯一索引&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">PRIMARY&lt;/span> &lt;span class="nf">KEY&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UNIQUE&lt;/span> &lt;span class="n">KEY&lt;/span> &lt;span class="err">`&lt;/span>&lt;span class="n">unidx&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="n">uni&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">KEY&lt;/span> &lt;span class="err">`&lt;/span>&lt;span class="n">seqidx&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="n">seq&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span> &lt;span class="n">AUTO_INCREMENT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">301&lt;/span> &lt;span class="n">DEFAULT&lt;/span> &lt;span class="n">CHARSET&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf8mb4&lt;/span> &lt;span class="n">COLLATE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf8mb4_bin&lt;/span> &lt;span class="n">COMMENT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">&amp;#39;简单测试表&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM0YjI2MzBiMDNjZTAzYWFkMGRlNDkwMjViNzg2YzVfbDIzM0Y5bzdsbWpRY3poRWJXQWNrNFRtbmVUb2JWaFlfVG9rZW46RjJDWmJZZGl3b21aaHB4QmR6c2NDbmV6bnVkXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h4 id="单一查询且查询结果存在id15">单一查询且查询结果存在(id=15)
&lt;/h4>&lt;p>存在一个意向表锁和行级读锁，理论上锁住的应该是(5, 15]这部分，但是由于是主键索引（唯一），所以只会锁15这一行，没有必要锁前面的间隙；这是优化1的体现；&lt;/p>
&lt;p>&lt;strong>LOCK_MODE为S,REC_NOT_GAP，我理解应该是说只有行锁，行锁类型是读锁；&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU4YmEzMzhiN2FmYjg5OGY4MTZkYjQ4ZWJkYmNiOThfd2hTc1d5a3ppdHJPQ0k2M1kzVnJmSGoxTXp1OUZaUDZfVG9rZW46T3VLaWJKNWtUb1dOM054WHpIT2NKdjRjbmViXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h4 id="单一查询且结果不存在id16">单一查询且结果不存在(id=16）
&lt;/h4>&lt;p>将查询条件从15换成了16，理论上锁住的是（15,20]这部分，但是实验表明，20这行不会加行锁，所以最终表现为(15,20)；这是优化2的体现；&lt;/p>
&lt;p>LOCK_MODE为S,GAP，我理解应该是说只有间隙锁，即（15,20）；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">insert&lt;/span> &lt;span class="n">into&lt;/span> &lt;span class="nf">simple&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">seq&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">value&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="c1">//会被阻塞
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">update&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="c1">//发现这行可以执行成功
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">既然可以成功，那就证明&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span> &lt;span class="err">的查询并没有锁&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="err">这一行，不然不可能加的上写锁&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzhiY2ZhMjQ0OWJiZThjOTU3OWM5MzFjYzU4NGQ2NjVfbFR0T3RQRTVMd29zdm1xa0VrbHRQWERaYXFyUEZGeU1fVG9rZW46V0R3Y2JxYUpEb0gyZWV4TTB5QWNSWGZVbkNlXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU3OGU2Yjk1NjhkMGNjYjI0YjkwNjZiMzAwNTQ4OGZfbGNST0VFS1RNbHV1NzJtVUhEU1ZIRXdnSzR1R25FVjVfVG9rZW46UFhCaGJPMTBQb2ZSd2d4MHFBVWM1UzhtbnNmXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>那这里如果我把id为20的更新成id为16会怎样？&lt;/p>
&lt;blockquote>
&lt;p>update simple set id=16 where id=20;&lt;/p>
&lt;/blockquote>
&lt;p>经实验16-19都不能更新，20以后可以更，比如update simple set id=21 where id=20就可以成功；所以间隙锁是不是也能防止更新；又或者说，其实是因为更新的本质是删除再插入，再插入的被阻塞了，这里感兴趣的可以研究一下；&lt;/p>
&lt;h4 id="范围查询">范围查询
&lt;/h4>&lt;h5 id="id5">id&amp;gt;5
&lt;/h5>&lt;p>按照理论，应该锁住的后5往后的所有范围，即(5,15],(15,20],(20,23],(23,super..];&lt;/p>
&lt;p>所以我推测&lt;strong>LOCK_MODE只有一个S，代表加的是临键锁，类型是读锁&lt;/strong>，没有特殊表明缺少行锁或者间隙锁就是完整的临建锁，并且我在console2尝试插入id为6或者36的，都会被阻塞&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">都会被阻塞&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">insert&lt;/span> &lt;span class="n">into&lt;/span> &lt;span class="nf">simple&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">seq&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">value&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">insert&lt;/span> &lt;span class="n">into&lt;/span> &lt;span class="nf">simple&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">seq&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">value&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">36&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVhOWRlZmVhZDNkNzRkODZlMGFkMzcyN2E2Yjk1ZDdfWnh1WXJOOHg4aXJMZTRDVzllZHZTS2g3bDlIWGk1dkFfVG9rZW46SkVDYmJOY0ZOb3hhTU94d0o1Q2NnekhtbmNlXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h5 id="id5-1">id&amp;gt;=5
&lt;/h5>&lt;p>和上面的唯一区别就是多了个等于5，那么5上是临键锁还是行锁呢？我觉得是行锁，因为优化1，而且这样和我们的认知也是比较符合的；&lt;/p>
&lt;p>实际看到确实是这样；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjNhODlkYTg5MzMwZjZlZjJmMTg4M2YwZWM3M2IwZjRfR1RmSFhSMkdTUHRnSFlUOFBiMkwxTTlFdlBkSUY1UzFfVG9rZW46VDY4TmJJUkRSbzcxYzh4cmowT2M1d2c2blZnXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h5 id="id5-and-id20">id&amp;gt;5 and id&amp;lt;20
&lt;/h5>&lt;p>首先5&amp;lt;x&amp;lt;20，那么正常情况应该是(5,15]和(15,20]，然后20因为不等于会被优化（触发了优化2)，所以是(5,20)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFjMzBlNDM2YWMxM2IwODYzZWM2MWU2MjU5YThlZTVfRVA1WlQ0UmlvcHdEWjFmQVBPSG9sV1o0anJNZkNLc05fVG9rZW46T3drMmJKVWxSb1pmenl4SXlmd2Mzb08zbmxnXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h5 id="id5-and-id20-1">id&amp;gt;5 and id&amp;lt;=20
&lt;/h5>&lt;p>假如是5&amp;lt;x&amp;lt;=20，那就会是(5,20]；&lt;/p>
&lt;p>但是注意我们前面提到过一个bug，可是我们看到目前就是锁到20为止，并不是(5,23)，翻看评论区说在MySQL 8.0.18 已经修复,而我的版本是8.0.33，这里难道是修复了吗？先存疑，因为这里只能证明主键索引修复了，后面唯一索引那里还是乱的一批&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=Njc1MzBmNWUwMGQwZWYzNzc5MTNkZTBmZDI4YjExMWVfN0JKaGlRY1pzSTBwQ2RqdjN5NTJLUkVMWFEwdElpZ3FfVG9rZW46VUJ5WWI3S0Rrb2M2ckF4ZFJwZWNHQVUybkdiXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h5 id="id30">id&amp;gt;30
&lt;/h5>&lt;p>应该会直接锁(23,super&amp;hellip;)&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTgxMDFmYzU1MmUwMjEwNTg0MmY0MWFjMjljN2EzMWNfT2U5bDZXS3RIb083Z0RQMlMwd2ZpbEoyS3lGV0pGcEVfVG9rZW46RER3bGIwbXcyb2lZWkF4MzhteWM0YTdDbnlkXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h3 id="case4next-key-lock和-unique-key">case4(next-key lock和 unique key)
&lt;/h3>&lt;p>和case3唯一的区别就是将主键索引换成了唯一索引，猜测应该是一模一样的，因为文档里的特殊规则说的也都是唯一索引，而没有限制到主键上；&lt;/p>
&lt;h4 id="单一查询且查询结果存在uni15">单一查询且查询结果存在(uni=15)
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBhOGU3YjhiMzEwNjAzMzQ5MDFkZjBjMzQ1YTM3YTRfVDZjeWlHSDhhN3hjTzBEYjFaUXRPdXIyeld3b1VYV3pfVG9rZW46TFFBRmJ2SW00b0FMeXd4aHdtRWNlRGJ2blFBXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>理想很美好，现实很骨感；这是什么？？突然想到行锁和间隙锁都是锁在索引上的锁，由于我查询结果是所有字段，所以会发生回表查询；当命中到唯一索引的时候会锁一次，然后根据主键id再锁一次；&lt;/p>
&lt;p>但是现在我的uni和id字段值是一样的，所以为了区分，我将uni这一列都加了100，然后执行下面的句子&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">115&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">115&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODA3Y2YzNmEzOGUzOWM2MDBlN2M4NDNhOTRkYTA2NzlfZnlEcEd1Rmc1bmlvSnNqQWJOcDBjTHlURktycER0TE9fVG9rZW46WDFLRWJNSnc4b2VPa0N4bXlpYWNpcHNPbjVkXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>可以看到primary那行应该是因为回表操作，而unidx那行应该则是对应唯一索引的查询，实际锁的范围和主键索引是一致的，只不过锁的内容我不理解，lock_data为115,15，为什么？&lt;/p>
&lt;p>而且如果我们查询的不是select *,而是select id ,锁的信息就不包含primary那行了；&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjg2ZjE2ZDFiMDc5ZmQ4MjNkODc3NmY0ZTNiOGJiMTRfd2Y4a3VRRU9BY0Q5YkFNMjZMdDl4Uk4wNEFBWVp3VWNfVG9rZW46SzhLbWJ6S0hyb1JHamp4cXdxUmNKUFJkbk1kXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h4 id="单一查询且结果不存在uni116">单一查询且结果不存在(uni=116）
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">116&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTg0YmZhOTkzMzFiM2JiOGY3OWE1ZmQ1Yzk0MGU5YjJfbEIxMU5zN0h0dXpMWmlNRHZDMEY2TEFnbDNydWljSmNfVG9rZW46WVhDaGJZNGN6bzB6STF4RW5vNGNGYnFrblJjXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>由于查询不到，所以也不会回表查询，就不存在primary那行了&lt;/p>
&lt;h4 id="uni105">uni&amp;gt;105
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">simple&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">uni&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">105&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NmRiZTAyM2Q4Yzc5Njc2Y2IzYTIyYzlkNmVhZWVlNjJfT0VDcUlFTWZFaDFOaXlnZHlJOWxVRE43NWpDRjY5alZfVG9rZW46UmFHTWJFdkdib2pSa1V4MDVLYmNkSFB1bjhnXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>我理解到每个索引节点的时候，都会执行一次select * from simple where id = x；所以会多出几行只有行锁primary的记录；&lt;/p>
&lt;p>uni&amp;gt;=105只是会在unidx和primary上各多一个锁，但范围和唯一索引依然一致，就不贴了&lt;/p>
&lt;h4 id="uni105-and-uni120">uni&amp;gt;105 and uni&amp;lt;120
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">commit&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">105&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">120&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">120&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">update&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="c1">//被阻塞
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTVmYjM4OGU1NGNhYzEyMDhkMTJhODk4MDIwNjg4NWZfVnc1VVdEWnp3MGtYWkhUWVhXWGJPT2l2ek1wMzJwelpfVG9rZW46V0c1WGI4V2Z4b3h6aE14WFdxa2NjNWlCbnpoXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>这里和上面不一样的是，这里把120这行也锁上了，主键索引锁20是间隙锁，这里是临键锁；为什么这里会锁上呢？就很像是bug并没有修复，依然锁到了第一个不满足条件的，并且加了临键锁&lt;/p>
&lt;h4 id="uni105-and-uni120-1">uni&amp;gt;105 and uni&amp;lt;=120
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">commit&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">105&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">120&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGI3NTIyZWYxMDE1YjFlZTBiZWNhZDQzOWQ0YjQ0YmFfOEViNW4xQUlxcEw5YXROOVUzTUpEQXYzS0piV0dpb3pfVG9rZW46VGdtdWJ3RWx0b3g3Y1p4YXNMRGMzVnBubkxlXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>这里更离谱，这里为什么把123都给锁上了？？感觉bug依然存在，多锁了一个区间&lt;/p>
&lt;h4 id="uni130和上面的id30结果一样就不贴了">uni&amp;gt;130和上面的id&amp;gt;30结果一样，就不贴了
&lt;/h4>&lt;p>总结：对于唯一索引来说，因为存在主键，那么会产生回表操作，回表操作会给主键再加一把锁；而那个bug依旧存在，只有主键索引的修复了，非主键唯一索引依然存在这个bug;&lt;/p>
&lt;h3 id="case5索引加在哪">case5（索引加在哪）
&lt;/h3>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGU4NzgzZWQ2MzJjZWQwN2ViOTA5ZTRmYjI3MzY2YTZfZ3cwRWxOeE1qTXRVT2x3aUM2VUdZQ29iR3U0aWZzSDJfVG9rZW46Q0xEMWJUUllUb1ZXMHZ4WlNVcmNJOWU5bnBjXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">105&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">update&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">set&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="err">&amp;#39;&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们已经清楚，执行完console1之后，会给unidx加一个行锁，因为没有回表，所以主键上没有锁；那么console2能否成功执行呢？&lt;/p>
&lt;p>答案是，可以的；&lt;/p>
&lt;p>我个人理解，是因为锁是加在索引上的，而索引是列维度的，不是行维度的；console2执行语句只会去判断id这个索引上，有没有5这个锁；&lt;/p>
&lt;p>接下来我们反过来&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//console2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">update&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">set&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="err">&amp;#39;&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">105&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你试着一起敲一下就会发现，咦，console2怎么阻塞了呢？按上面所说的，不是不应该吗？&lt;/p>
&lt;p>实际上console1的执行锁的确实是id；&lt;/p>
&lt;p>但是你console2的执行，会回表啊，会尝试给id加写锁，但是id已经加了读锁了，所以自然不行了；&lt;/p>
&lt;p>所以，不要盲目的只看查询条件，要理解当前语句都会加什么锁，是否和已经加的锁冲突；&lt;/p>
&lt;p>最后，我们再来看一个附加题，下面两个语句加的锁是否一样呢？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">105&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">uni&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">105&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">update&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在我没有尝试之前，我理解都没有回表，那么就应该一个是唯一索引加读锁，一个是唯一索引加写锁；&lt;/p>
&lt;p>但是实际结果却是lock in share mode是对的，for update会认为你要更新语句，自动给主键加锁了&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQ0OWZhMTI0MzZiZWJmNzgxODI0YjcwYzAyNDQ1NWFfQXRuTGZzTnB3N3NCZjZtMjFOZlJEYm52eldRZWdEQU5fVG9rZW46R0Y0QWJCdHdIb3ZDWXN4TEl0V2NwWWxtbjZjXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h3 id="case6next-key-lock-和index">case6（next-key lock 和index）
&lt;/h3>&lt;p>吸取uni的教训，我给seq的值都加了200，现在这个表是这样的&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjkwZTU1MzBhZDNlNzljNWQ3NmUzNzFkOTJlNDk4MjVfUXBLbXRzMWtDNVN0Ujc4dmphbjRVQW5FWFpac1NqVjRfVG9rZW46Vm5yQWJRbVNjb0lOR3h4M2ZIb2N5SWRKbjVnXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;h4 id="seq215">seq=215
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">seq&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">215&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWNhMTEwODA3NGRkMDI5NTg5MTNkY2IwMWJkOWJkMWNfcFVDN2M1Zkl0SHV5bFNIcTNGTGJhNXFMTEtjSkN3bkFfVG9rZW46SWEzSWJySmozb0hvaHZ4TlBucWNLNnFHbk82XzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>除了意向锁，其他三个我们一个个看；&lt;/p>
&lt;p>seqidx(S)这行是普通索引执行时加的临键锁，由于不是唯一索引，所以不能优化（因为可能存在重复）&lt;/p>
&lt;p>primary(S,REC_NOT_GAP)这是回表操作带来的&lt;/p>
&lt;p>seqidx(S,GAP)这行是因为不是唯一索引，所以在查询到匹配的值之后不会立马停止（因为后面可能还存在相同的值），所以必须要到不符合条件的值为止，而所有查询过的都会加索引，所以存在一个间隙锁。&lt;/p>
&lt;h4 id="seq216">seq=216
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">seq&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">216&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTJmYmFkNGQwMTY5Mjc5YjZhMWU4MTdkMmNhZGU2NTJfV0F6cHFnS1M1Mlh2V2RDMjZ1RWdnc2lPbnBJQUVCMGhfVG9rZW46QXh5RWJaMXJvbzU3Tk54dDU1S2NremVDbmlnXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>我理解，应该是从205开始查，查到第一个不符合条件的值是215，加上中间没有回表，所以就这一个锁；理论应该是(215,220]，但由于优化2，所以退化为间隙锁；&lt;/p>
&lt;h4 id="seq215-and-seq220">seq&amp;gt;215 and seq&amp;lt;220
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">seq&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">215&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">seq&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">220&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从215开始匹配，第一个不符合条件的是220，所以只能是（215,220]&lt;/p>
&lt;h4 id="seq215-and-seq-220">seq&amp;gt;215 and seq &amp;lt;=220
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">seq&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">215&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">seq&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">220&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU1M2M3NjdkZDY3ZDY5M2NmMWEzNDI2ODI2ZDczYTdfZW5PRWlERDdVWVdwbzNpUEVzekJZUXlzY1BaQlpWNEpfVG9rZW46VFozRGJ0NUcyb3h4RWV4dFYzR2NDT293bnJiXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>这里和上面区别就是不符合条件的会到223为止，另外中间因为匹配成功会回一次表&lt;/p>
&lt;h4 id="seq230和前面unidx130和id30都一样">seq&amp;gt;230和前面unidx&amp;gt;130和id&amp;gt;30都一样
&lt;/h4>&lt;h3 id="case7next-key和没有索引">case7(next-key和没有索引）
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">alter&lt;/span> &lt;span class="n">table&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">drop&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="n">seqidx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">simple&lt;/span> &lt;span class="n">where&lt;/span> &lt;span class="n">seq&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">215&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">share&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data_locks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>前面提到过，查询条件匹配不到索引或者只是索引的一部分，这个时候为了保证数据的准确性，会给整个表“加锁”，其实给表里所有的记录都加锁(这里我不知道描述的对不对，因为表锁！=所有记录加锁，虽然效果相似，但并不是一个东西）.&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjNiMmMzNzIzZTY2MWI1Y2QzNzU0Y2I1ZjU5NWU1N2JfbXJXYVZSMmg5WFlxMFlReDBOVXRJU1ZVaEpBREVhd2JfVG9rZW46S0dHdGJNUXZ2bzV4ZTJ4bkgxNmNyaWFablFkXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="https://l8ut65fgfc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NlY2VhOGI3ZjA0ZDZlOTVkZTlmMWQyMjg0NGY1MTdfd1dRc2VzTW9QNDJQcFQ3Q01lTnlMOXN2d2JRbHE3RXdfVG9rZW46QmxVcmJXSVdFb2VIdDF4NWhkYWNjdXNrbndDXzE3MjMzNjUyOTQ6MTcyMzM2ODg5NF9WNA"
loading="lazy"
>&lt;/p>
&lt;p>同时因为这个表存在意向读锁，通过lock tables simple write 加写的表锁会冲突；&lt;/p>
&lt;h2 id="疑问">疑问
&lt;/h2>&lt;p>对于事务和表锁一起用的情况，到底要使用set autocommit=0吗？why？&lt;/p>
&lt;ul>
&lt;li>The correct way to use &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">LOCK TABLES&lt;/a>&lt;/code>&lt;/u> and &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">UNLOCK TABLES&lt;/a>&lt;/code>&lt;/u> with transactional tables, such as &lt;code>InnoDB&lt;/code> tables, is to begin a transaction with &lt;code>SET autocommit = 0&lt;/code> (not &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/commit.html">START TRANSACTION&lt;/a>&lt;/code>&lt;/u>) followed by &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">LOCK TABLES&lt;/a>&lt;/code>&lt;/u>, and to not call &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">UNLOCK TABLES&lt;/a>&lt;/code>&lt;/u> until you commit the transaction explicitly. For example, if you need to write to table &lt;code>t1&lt;/code> and read from table &lt;code>t2&lt;/code>, you can do this:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">autocommit&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LOCK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TABLES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WRITE&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">READ&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">do&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">something&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">with&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">here&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="k">COMMIT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">UNLOCK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TABLES&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>When you call &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">LOCK TABLES&lt;/a>&lt;/code>&lt;/u>, &lt;code>InnoDB&lt;/code> internally takes its own table lock, and MySQL takes its own table lock. &lt;code>InnoDB&lt;/code> releases its internal table lock at the next commit, but for MySQL to release its table lock, you have to call &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">UNLOCK TABLES&lt;/a>&lt;/code>&lt;/u>. You should not have &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit">autocommit = 1&lt;/a>&lt;/code>&lt;/u>, because then &lt;code>InnoDB&lt;/code> releases its internal table lock immediately after the call of &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html">LOCK TABLES&lt;/a>&lt;/code>&lt;/u>, and deadlocks can very easily happen. &lt;code>InnoDB&lt;/code> does not acquire the internal table lock at all if &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit">autocommit = 1&lt;/a>&lt;/code>&lt;/u>, to help old applications avoid unnecessary deadlocks.&lt;/li>
&lt;/ul>
&lt;h2 id="参考文档">参考文档
&lt;/h2>&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-shared-exclusive-locks" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-shared-exclusive-locks&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://time.geekbang.org/column/article/69862" target="_blank" rel="noopener"
>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？-极客时间&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/q2878948/article/details/96430129" target="_blank" rel="noopener"
>mysql MDL读写锁阻塞，以及online ddl造成的“插队”现象_花落的速度的博客-CSDN博客&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/zbh1957282580/article/details/122457542" target="_blank" rel="noopener"
>MYSQL查看表是否被锁、以及解锁_mysql查看锁表_清石小猿的博客-CSDN博客&lt;/a>&lt;/p></description></item><item><title>MVCC机制</title><link>https://blog.qisiii.asia/post/tech/mysql/mvcc/</link><pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate><guid>https://blog.qisiii.asia/post/tech/mysql/mvcc/</guid><description>&lt;img src="https://blog.qisiii.asia/blog-img/mvcc.png" alt="Featured image of post MVCC机制" />&lt;h2 id="事务隔离级别遗留问题">事务隔离级别遗留问题：
&lt;/h2>&lt;p>在读已提交的级别下，事务B可以读到事务A持有写锁的的记录，且读到的是未更新前的，为何写读没有冲突？&lt;/p>
&lt;p>可重复读级别，事务B可以更新事务A已经获取读锁的记录，且更新后，事务A依然可以获取读锁，为何读-写-读没有冲突？&lt;/p>
&lt;p>在可重复读级别，幻读没有产生？&lt;/p>
&lt;p>其中，前两个问题就是因为mvcc机制（读锁的一种优化机制），通过不加读锁，避免读写冲突，进而提高了性能。&lt;/p>
&lt;p>而第三个问题，一部分原因是由MVCC机制保证的，还有一部分则是由锁来保证的；&lt;/p>
&lt;p>两次查询都是当前读或快照读，不会出现幻读问题；&lt;/p>
&lt;p>第一次查询是快照读，第二次是当前读，会出现幻读问题；&lt;/p>
&lt;h2 id="在学习了解mvcc机制中遇到的问题">在学习了解MVCC机制中遇到的问题：
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>为什么更新操作必须使用当前读？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只读事务突然更新的话，因为更新必须使用当前读，那是否需要重新生成事务id?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只读事务分配的事务id是什么东西？如何参与运作？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>readview的范围&lt;/p>
&lt;/li>
&lt;li>
&lt;p>知道了mvcc底层是undolog和readview后，怎么理解“版本”这个概念&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在只读视图能查到其他事务已经删除并且提交的记录吗？&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="为什么要有mvcc机制">为什么要有MVCC机制？
&lt;/h1>&lt;ol>
&lt;li>
&lt;p>在读已提交的级别下，由于是给读加锁来保证读已提交， 如果事务A持有写锁，为了保证读已提交，事务B必须等待事务A提交之后才可以读；其他的读事务也是这样的情况，效率太低&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在可重复读级别，为了保证可重复读，如果事务A持有读锁，为了第二次读到的一样，其他所有写事务必须等待读完才可以，同样效率低&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>那么很自然的想到，无论读事务是先产生还是后产生，如果这个时候还存在写事务没有执行，或者需要执行；那么就应该让读事务读到目前最新的值，且写事务可以更新；只不过读事务在写事务提交更新后，依据隔离级别是否可见最新更新即可。这就是MVCC机制的核心能力，将读锁干掉。&lt;/p>
&lt;h1 id="mvcc机制核心组件">MVCC机制核心组件
&lt;/h1>&lt;p>MVCC机制由&lt;strong>版本链、undolog、readview&lt;/strong>三大核心构成&lt;/p>
&lt;h2 id="版本链">版本链
&lt;/h2>&lt;p>猜测很多人第一次看到MVCC的版本都是和我一样在各种各样的博客文章上，或者可能是在一些课程专栏或者《高性能mysql》这本书的mvcc部分看到的，那么在你的理解中，版本的底层是什么样子呢？&lt;/p>
&lt;p>innodb引擎数据库中的每一条记录上，我们都可以认为上面有3个隐藏字段，分别是DB_ROW_ID(不在此次讨论范围),DB_TRX_ID和DB_ROLL_PTR,如下图一样&lt;/p>
&lt;p>&lt;img src="http://picgo.qisiii.asia/post/w39dhfwj7v37x15wz_psyqmc0000gn/T/e521c7808ece6cc93109159eebee8efa.jpg"
loading="lazy"
>&lt;/p>
&lt;p>在我的理解中，&lt;/p>
&lt;p>DB_TRX_ID就是插入或者更新时，当前事务的trx_id，由全局事务管理器分配的递增的一个id；&lt;/p>
&lt;p>DB_ROLL_PTR存储的undolog中当前记录上一个版本的指针，先姑且记住这是一个指针。&lt;/p>
&lt;p>&lt;strong>当插入一条记录时&lt;/strong>&lt;/p>
&lt;p>在这条记录的DB_TRX_ID填入当前事务的id，由于没有历史版本，所以DB_ROLL_PTR为空&lt;/p>
&lt;p>&lt;strong>当更新一条记录时&lt;/strong>&lt;/p>
&lt;p>由于这个时候存在历史版本，所以需要将老版本的数据写到undolog里，然后构建指针&lt;/p>
&lt;p>将DB_TRX_ID更新为当前事务的id,将DB_ROLL_PTR更新为刚才构建的指针，以及更新需要更新的字段。&lt;/p>
&lt;p>&lt;strong>当删除一条记录时&lt;/strong>（这个不太确定，主观猜测）&lt;/p>
&lt;p>猜测是将老记录写到undolog，然后构建指针&lt;/p>
&lt;p>新记录DB_TRX_ID更新为当前事务的id,将DB_ROLL_PTR更新为刚才构建的指针，但是没有需要更新的字段。&lt;/p>
&lt;p>mysql不会立即删除，记录上有一个info_bits字段，会标记上删除标识(REC_INFO_DELETED_FLAG)，后续由purge线程（不了解，姑且认为是个scheduleTask吧)删除&lt;/p>
&lt;p>这样，当多次更新之后，新记录存储的永远都是最新操作的事务id，并通过指针指向了老版本，老版本还指向了更老的版本&amp;hellip;等等，最终构成了一个版本链&lt;/p>
&lt;h2 id="readview">Readview
&lt;/h2>&lt;h3 id="理论">理论：
&lt;/h3>&lt;p>在周志明老师的凤凰架构（或者极客时间的‘周志明的软件架构课’）中对mvcc简单介绍到&lt;/p>
&lt;blockquote>
&lt;p>隔离级别是可重复读：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。&lt;/p>
&lt;p>隔离级别是读已提交：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。&lt;/p>
&lt;/blockquote>
&lt;p>在mysql官网中是这么描述的&lt;/p>
&lt;blockquote>
&lt;p>If the transaction &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_isolation_level" target="_blank" rel="noopener"
>isolation level&lt;/a> is &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">REPEATABLE READ&lt;/a>&lt;/code>&lt;/u> (the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction. You can get a fresher snapshot for your queries by committing the current transaction and after that issuing new queries.&lt;/p>
&lt;p>With &lt;u>&lt;code>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed">READ COMMITTED&lt;/a>&lt;/code>&lt;/u> isolation level, each consistent read within a transaction sets and reads its own fresh snapshot.&lt;/p>
&lt;/blockquote>
&lt;p>翻译：&lt;/p>
&lt;p>隔离级别是可重复读：在同一个事务中，一致性视图是在总是去第一次读取时生成的快照。&lt;/p>
&lt;p>隔离级别是读已提交：事务中的每次读取都取自己新生成的快照。&lt;/p>
&lt;hr>
&lt;p>相比之下，周老师形容的更贴近隔离级别的概念上，官方的描述则是底层的具体实现逻辑。&lt;/p>
&lt;p>两者结合一下就是&lt;/p>
&lt;p>&lt;strong>可重复读：通过在每个事物只读取第一次select时生成的快照和undolog比较，根据一个可见性规则判断，是否可以读当前版本的记录，可以就返回，不行就继续比较再上一个版本，直到最老的版本；&lt;/strong>&lt;/p>
&lt;p>&lt;strong>读已提交：除了每次读取都会使用最新的快照，后面的都和可重复读的逻辑一样。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>为什么我这里说的是可见性规则呢？&lt;/strong>&lt;/p>
&lt;p>是因为周老师描述里“总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录”&lt;/p>
&lt;p>很容易错误的理解为当前版本记录里的trx_id&amp;lt;=快照创建时的事务id(create_trx_id)就都可见，真正的判断逻辑并不只是一个create_trx_id就能搞定的。&lt;/p>
&lt;p>但这里先不展开讲，自己想一下为什么不行，下面的图可能会给你一点灵感，接下来我们先去读一下“可见性规则”的底层源码。&lt;/p>
&lt;p>&lt;img src="http://picgo.qisiii.asia/post/w39dhfwj7v37x15wz_psyqmc0000gn/T/883681f8f84cf11ec505df8396950113.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="可见性规则底层实现">可见性规则底层实现
&lt;/h3>&lt;h4 id="readview类">ReadView类
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">storage&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">innobase&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">include&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">read0types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">h&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">47&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//ReadView类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">class&lt;/span> &lt;span class="n">ReadView&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">private&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/** trx id of creating transaction, set to TRX_ID_MAX for free
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> views. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//创建快照的时候，快照对应的事务id，只有含有写操作的才会分配真正的事务id
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">trx_id_t&lt;/span> &lt;span class="n">m_creator_trx_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/** Set of RW transactions that was active when this snapshot
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> was taken */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//活跃的读写事务id列表，从trx_sys-&amp;gt;rw_trx_ids抄过来的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">ids_t&lt;/span> &lt;span class="n">m_ids&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/** The read should not see any transaction with trx id &amp;gt;= this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> value. In other words, this is the &amp;#34;high water mark&amp;#34;. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//赋值是即将分配的下一个事务id，所以大于等于这个id的记录对当前事务来说都是不可见的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">trx_id_t&lt;/span> &lt;span class="n">m_low_limit_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/** The read should see all trx ids which are strictly
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> smaller (&amp;lt;) than this value. In other words, this is the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> low water mark&amp;#34;. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//m_ids不为空就是ids.get(0)，为空则是m_low_limit_id,所以小于这个事务id的就代表着快照建立的时候
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//已经不是活跃事务了，即已经提交了，所以一定可以看到这些事务的改动记录
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">trx_id_t&lt;/span> &lt;span class="n">m_up_limit_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="初始化赋值的时候">初始化赋值的时候
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//read0read.cc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//row_search_mvcc -&amp;gt; trx_assign_read_view -&amp;gt; MVCC::view_open -&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">ReadView&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="nf">prepare&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">trx_id_t&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">trx_sys_mutex_own&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_creator_trx_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_low_limit_no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">trx_get_serialisation_min_trx_no&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_low_limit_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">trx_sys_get_next_trx_id_or_no&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_low_limit_no&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">m_low_limit_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">trx_sys&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rw_trx_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">copy_trx_ids&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx_sys&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rw_trx_ids&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">clear&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* The first active transaction has the smallest id. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_up_limit_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">m_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="n">m_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">front&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">m_low_limit_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_up_limit_id&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">m_low_limit_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_d&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_view_low_limit_no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">m_low_limit_no&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_closed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="判断某个版本的记录是否可见">判断某个版本的记录是否可见？
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//read0types.h
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">changes_visible&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">trx_id_t&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">table_name_t&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果当前版本记录上的事务id（DB_TRX_ID）小于低水位或者等于当前事务，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//那么要么就是自己更改的，要么就是历史上已经提交了的，所以可以读到
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">m_up_limit_id&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">m_creator_trx_id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">check_trx_id_sanity&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果当前版本记录上的事务id（DB_TRX_ID）大于高水位，那么就是在当前快照生成后生成的事务，一律看不到
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">m_low_limit_id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//这一步我没有理解，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">m_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">ids_t&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">value_type&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">m_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">data&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//二分查找，如果活跃的事务里面没有，那么就返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//这里我是这么理解的，[低水位,高水位]包含活水和死水，即活跃的事务和已经提交的事务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//假如存在事务1是活跃的，事物2是已提交的，事务3是活跃的，我们在事务4的时候开启快照，很明显我们只能读到事务2或者事务4的变更
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//假如正在判断的是事务2，因为已经经过了上面的校验，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//所以我们知道当前版本记录的事务m_low_limit_id（高水位）&amp;gt;id&amp;gt;=m_up_limit_id（低水位)，且不是当前事务;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//所以就需要判断事务只要不是活跃的，那么就一定是已经提交的事务，那么就可读
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="nf">binary_search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">m_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">size&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="http://picgo.qisiii.asia/post/w39dhfwj7v37x15wz_psyqmc0000gn/T/8eb5ad315ac2ebe605e451169ea0cf37.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="事务的trx_id">事务的trx_id
&lt;/h3>&lt;p>在我还没开始看mysql源码，只是跟着博客学习写用例测试的时候，我发现，开启事务进行了第一次查询之后，确实有生成事务id，但后面我更新了之后，原来的事务id变了；就像下面这个图一样，最开始只有查询的时候是比较长的这个id,但执行了一条update语句后，事务id变成了一个短的。&lt;/p>
&lt;p>&lt;img src="http://picgo.qisiii.asia/post/w39dhfwj7v37x15wz_psyqmc0000gn/T/a3ea6c5726c3d20ea3275b4ec84f341b.jpg"
loading="lazy"
>&lt;/p>
&lt;p>这个时候我就产生了很多疑问？同一个事务里，事务id怎么还能变呢？变的话changes_visible里面的比较怎么算？搜索了一下之后了解到，只读事务是不会生成事务id的，是假的！于是我又疑惑，那这个假id怎么参与changes_visible呢？也就是这个时候，我才下定决心去看源码，也借此理解了高低水位的设计，并认识到自己之前的理解是错误的。&lt;/p>
&lt;p>&lt;strong>先上结论&lt;/strong>&lt;/p>
&lt;p>&lt;strong>只读事务不会分配真正的事务id，他的值是0；&lt;/strong>&lt;/p>
&lt;p>&lt;strong>只读事务参与change_visable的时候，create_trx_id也确实是0，是通过m_up_limit_id（低水位）来判断是否可见的，只有在变成读写事务是，create_trx_id才会起效并应用；&lt;/strong>&lt;/p>
&lt;p>因为&lt;strong>值是0，在通过下面sql查询的时候，那串id只是展示的时候特殊处理的&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">select&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">INNODB_TRX&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//trx0trx.cc#trx_start_low
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//这里可以看到只有读写事务才真正分配了id
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//开始是0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">trx_is_autocommit_non_locking&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* If this is a read-only transaction that is writing
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> to a temporary table then it needs a transaction id
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> to write to the temporary table. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">read_write&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">trx_sys_mutex_enter&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">srv_read_only_mode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">store&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TRX_STATE_ACTIVE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memory_order_relaxed&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">trx_sys_allocate_trx_id&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="c1">//这里进行分配
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx_sys&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rw_trx_ids&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">trx_sys_mutex_exit&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">trx_sys_rw_trx_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">store&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TRX_STATE_ACTIVE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memory_order_relaxed&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">read_write&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">store&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TRX_STATE_ACTIVE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memory_order_relaxed&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//trx0trx.ic
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//这里是在展示的时候对只读事务的id做了处理
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">@&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="err">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">trx_id_t&lt;/span> &lt;span class="nf">trx_get_id_for_print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">trx_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* DATA_TRX_ID_LEN is the storage size in bytes. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">trx_id_t&lt;/span> &lt;span class="n">max_trx_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1ULL&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">DATA_TRX_ID_LEN&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">CHAR_BIT&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">max_trx_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* on some 32bit architectures casting trx_t* (4 bytes) directly to
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> trx_id_t (8 bytes unsigned) does sign extension and the resulting value
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> has highest 32 bits set to 1, so the number is unnecessarily huge.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Also there is no guarantee that we will obtain the same integer each time.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Casting to uintptr_t first, and then extending to 64 bits keeps the highest
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> bits clean. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">?&lt;/span> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nl">id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">:&lt;/span> &lt;span class="kt">trx_id_t&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">reinterpret_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">uintptr_t&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="p">)}&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">max_trx_id&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="生成快照时机不太确定">生成快照时机（不太确定）
&lt;/h3>&lt;p>可重复读：只生成一次，后面继续使用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ReadView&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">trx_assign_read_view&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">trx_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="cm">/*!&amp;lt; in/out: active transaction */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">trx_can_be_handled_by_current_thread_or_is_hp_victim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memory_order_relaxed&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TRX_STATE_ACTIVE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">srv_read_only_mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ut_ad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_view&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">nullptr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nullptr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">MVCC&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="nf">is_view_active&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_view&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx_sys&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mvcc&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nf">view_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_view&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">trx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_view&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>读已提交：好像是用完就关，所以每次再获取就得新开，但是这里的关有两个地方调，不太确定上层是不是sql执行完的方法&lt;/p>
&lt;p>ha_innodb.cc#store_lock 和ha_innodb.cc#external_lock&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">lock_type&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">TL_IGNORE&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">n_mysql_tables_in_use&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">isolation_level&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">innobase_trx_map_isolation_level&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">thd_get_trx_isolation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thd&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">isolation_level&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">TRX_ISO_READ_COMMITTED&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MVCC&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="nf">is_view_active&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_view&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* At low transaction isolation levels we let
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> each consistent read set its own snapshot */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mutex_enter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">trx_sys&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">trx_sys&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mvcc&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nf">view_close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">trx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_view&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mutex_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">trx_sys&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="快照读和当前读">快照读和当前读
&lt;/h3>&lt;p>快照读：当前执行的sql如果不存在锁，那么默认读到的就是readview里的快照，这种情况称之为快照读；&lt;/p>
&lt;p>当前读：如果当前执行的sql存在锁，比如使用了lock in share mode,for update，或者是insert、update、delete操作，对于这种需要锁的sql，必须读取最新的视图，这种行为称之为当前读；&lt;/p>
&lt;p>我个人理解只有在RR级别才需要区分对待，RC级别都是当前读；而且我认为二者的区别就只有加锁和不加锁这一个点&lt;/p>
&lt;h1 id="回答文章最开始的一些问题">回答文章最开始的一些问题：
&lt;/h1>&lt;ol>
&lt;li>为什么更新操作必须使用当前读？&lt;/li>
&lt;/ol>
&lt;p>更新操作后的如果不回滚那没有事，如果要回滚，应该回滚到最新一次的提交，所以undo log里必须是最新的视图&lt;/p>
&lt;ol start="2">
&lt;li>只读事务突然更新的话，因为更新必须使用当前读，那是否需要重新生成事务id?&lt;/li>
&lt;/ol>
&lt;p>不算做重新，是只有在触发锁操作时会分配真正的事务id，只读事务分配的id其实就是0&lt;/p>
&lt;ol start="3">
&lt;li>只读事务分配的事务id是什么东西？如何参与运作？&lt;/li>
&lt;/ol>
&lt;p>没有作为判断条件，作为判断条件的是up_limit记录的是最小活跃id，小于他的才能读，正规的事务id分配的在readview结构里其实是creator_trxid，用来判断当前是否能被当前事务看见&lt;/p>
&lt;ol start="4">
&lt;li>readview的范围&lt;/li>
&lt;/ol>
&lt;p>有这个疑问还是因为最开始对change_visable掌握的不够清晰。&lt;/p>
&lt;p>之前想的场景是在事务A里，如果存在两条不同记录甚至不同表的查询，而事务B在第事务A两条查询中间的时候对第二条查询的记录做了更改并提交，那应该查到的是新的还是旧的。&lt;/p>
&lt;p>其实应该是旧的，因为就算是第二条查询，最新版本的改动的事务id会大于等于事务A的高水位，因此只能查询到更老的undolog里的记录&lt;/p>
&lt;ol start="5">
&lt;li>知道了mvcc底层是undolog和readview后，怎么理解“版本”这个概念&lt;/li>
&lt;/ol>
&lt;p>创建版本肯定就是字段里那个隐藏字段，删除版本应该是回滚指针&lt;/p>
&lt;ol start="6">
&lt;li>在只读视图能查到其他事务已经删除并且提交的记录吗？&lt;/li>
&lt;/ol>
&lt;p>经测试是可以的&lt;/p>
&lt;h1 id="怎么解决的幻读">怎么解决的幻读？
&lt;/h1>&lt;p>在只读事务下，如上文所说的事务1读不到事务2的更新是因为事务2的版本号要大于当前快照的高水位，那对于新增的记录来说，其版本号也是同样的道理，因此事务1读不到比当前快照里的高水位高的，也就避免了幻读这种情况。&lt;/p>
&lt;p>但是在当前读下，由于必须读取最新的结果，所以版本号一定是当前事务可见的，那么这个时候mysql的表现是什么样子呢？又是为什么是这样子呢？通过下面的实例来认识一下&lt;/p>
&lt;p>&lt;strong>simple表的初始情况&lt;/strong>&lt;/p>
&lt;p>&lt;img src="http://picgo.qisiii.asia/post/w39dhfwj7v37x15wz_psyqmc0000gn/T/510fd3bda9179c530cc27d8f0375c748.jpg"
loading="lazy"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Bash" data-lang="Bash">&lt;span class="line">&lt;span class="cl">//console1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span> * from simple&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span> * from simple where id &amp;lt;&lt;span class="m">10&lt;/span> lock in share mode &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//console2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">start transaction &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">insert into simple &lt;span class="o">(&lt;/span>id,name,seq,type&lt;span class="o">)&lt;/span> value &lt;span class="o">(&lt;/span>6,3,3,1&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">这个时候理论上事务2应该可以顺利插入id为6的记录，毕竟我们虽然加了读锁；但是记录都不存在必然也锁不住；
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">但是我们会发现insert这条语句被阻塞了，在等待一会之后会报下面的错
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Lock &lt;span class="nb">wait&lt;/span> timeout exceeded&lt;span class="p">;&lt;/span> try restarting transaction
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>既然锁等待了，就必然存在一个锁，不过锁的部分我还需要再研究研究。&lt;/p>
&lt;p>预计将在下一篇文章中介绍，敬请期待&amp;hellip;&lt;/p>
&lt;h1 id="参考资料">参考资料：
&lt;/h1>&lt;p>&lt;a class="link" href="https://juejin.cn/post/6949909210339639326" target="_blank" rel="noopener"
>MySQL 8.0 MVCC 源码解析 - 掘金&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/Win_Dan/article/details/119171531" target="_blank" rel="noopener"
>MySQL事务ID的分配时机_mysql事务id什么时候分配_哲学长的博客-CSDN博客&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="http://blog.itpub.net/7728585/viewspace-2142302/" target="_blank" rel="noopener"
>MYSQL innodb中的只读事物以及事物id的分配方式_ITPUB博客&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/scugxl/article/details/102911145" target="_blank" rel="noopener"
>Mysql如何实现隔离级别 - 可重复读和读提交 源码分析_mysql 可重复度源码_择维士的博客-CSDN博客&lt;/a>&lt;/p></description></item><item><title>事务隔离级别</title><link>https://blog.qisiii.asia/post/tech/mysql/transaction_isolation/</link><pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate><guid>https://blog.qisiii.asia/post/tech/mysql/transaction_isolation/</guid><description>&lt;h2 id="标准隔离级别">标准隔离级别
&lt;/h2>&lt;p>读未提交、读已提交、可重复读、串行化&lt;/p>
&lt;h3 id="串行化">串行化
&lt;/h3>&lt;p>对事务中所有读写的数据加上读锁、写锁、范围锁。所以冲突的事务必须同步执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;newTest&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">（由于事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">没有释放写锁，所以这里的查询会阻塞&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">如果等待时间过长，会报如下的错误；如果事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">只是查询，那么事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">也可以查询）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">40001&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">1205&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Lock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">exceeded&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">restarting&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;(&lt;/span>&lt;span class="err">提交完之后如果事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">没有等待超时，那么会立即执行&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="可重复读">可重复读
&lt;/h3>&lt;p>核心是只对事务中所有读写的数据加上读锁、写锁，不加范围锁。本应该如此，但是有mvcc优化。&lt;/p>
&lt;p>相比于读已提交，由于对整个事务都加上了读锁，避免其他事务可以进行更新，进而保证同一个事务多次读到的数据都是没有被修改过的数据。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">----避免可重复读----
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">name初始值为init&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">（查询结果是&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">理论上，由于事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">已经获取了读锁，事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">这里添加写锁应该是添加不上的&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">应该是阻塞中才对；&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">但是，实操发现，执行成功了，且在事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">中通过下面这个语句查询是&lt;/span>&lt;span class="n">test&lt;/span>&lt;span class="err">，这应该也是&lt;/span>&lt;span class="n">mvcc导致的&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">console1的第2次查询&lt;/span>&lt;span class="err">，查询结果和第一次一样，还是&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">另外，事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">都获得写锁了，怎么能允许你事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">再去获得读锁，还是因为&lt;/span>&lt;span class="n">MVCC机制搞的鬼&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相比于串行化，由于没有加范围锁，会引发一种叫幻读的情况&lt;/p>
&lt;p>所谓幻读是指在同一个事务中，第一次查询id&amp;lt;10的假定有1条，第二次查询可能会有2条，原因是在两次查询的中间，存在别的事务插入或者删除了数据，由于事务A只加了读锁或者写锁，只能防止其他事务对已经加锁的这几条数据进行修改，但避免不了插入和删除，所以才会出现这个问题。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">----幻读----
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">初始是&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;newddd&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">理论上来讲，这个地方应该会查到三条，但是实操发现，在事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">添加并提交之后，事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">查到了依然是原来的样子&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">即不存在幻读现象，这是怎么回事？&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">MVCC的优化&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;(&lt;/span>&lt;span class="err">提交之后再次查询就有新结果了）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="读已提交">读已提交
&lt;/h3>&lt;p>核心是对事务中需要更新的操作行加写锁，直到事务结束，但对&lt;strong>查询的操作行加读锁，但在查询完之后立即释放，即不是在整个事务范围锁定&lt;/strong>。&lt;/p>
&lt;p>读已提交通过对查询操作加锁来避免读未提交，在事务B修改数据时因为其在事务结束之前一直持有写锁，事务A无法对数据加读锁，只能等待事务B提交事务才可以读取，这也是读已提交的名称的由来。&lt;/p>
&lt;p>虽然解决了读未提交的问题，但是由于只在查询的时候短暂加了读锁，引发了另一个不可重复读的问题；&lt;/p>
&lt;p>所谓不可重复读是指在同一个事务中，对于同样一条数据的两次查询结果不一样，那么这个和幻读有什么区别呢？幻读整个事务中都存在读锁或者写锁，其他事务无法修改，只能增删；但是不可重复读，则是指当前已经查到的结果被更新了。&lt;/p>
&lt;p>原因是假如同一个事务两次查询中间，别的事务进行了修改，由于事务A没有加整个事务范围的读锁，所以事务B是可以成功获取写锁的，进而修改数据，最终导致了不可重复读。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">---避免读未提交----
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">name初始值是init&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">（由于读不到未提交的，所以肯定获取不到修改后的&lt;/span>&lt;span class="n">test值&lt;/span>&lt;span class="err">，理论上只能等待事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">结束）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">这个地方由于事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">已经添加了写锁，原则上事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">根本查询不了，应该阻塞，就像串行化那里一样&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">但是实际结果却是可以查到以前的值，即&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="err">；所以这里应该是&lt;/span>&lt;span class="n">mvcc的作用&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">在读已提交的级别下，&lt;/span>&lt;span class="n">mvcc机制总是取最新的版本即可&lt;/span>&lt;span class="err">，即最近被&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">的那个版本的数据记录。&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">这样保证了读到的都是已提交的事务&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="err">提交之后，事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">再次查询，发现已经可以获取到改动后的值了，即&lt;/span>&lt;span class="n">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">---不可重复读----
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">name初始值是init&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;(&lt;/span>&lt;span class="err">第一次查询是&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;(&lt;/span>&lt;span class="err">在事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">中更新并提交&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;(&lt;/span>&lt;span class="err">第二次查询是&lt;/span>&lt;span class="n">test&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="读未提交">读未提交
&lt;/h3>&lt;p>核心是对事务中需要更新的操作行加写锁，直到事务结束，但对&lt;strong>查询的操作行不加锁&lt;/strong>。&lt;/p>
&lt;p>引发的问题是脏读，其实就是读到了其他事务还没有提交的数据；那么为什么事务A可以读到事务B还没有提交的数据？&lt;/p>
&lt;p>分为两步理解:&lt;/p>
&lt;p>1.为什么存在可以读的新的数据?&lt;/p>
&lt;p>核心原因应该是write-ahead logging的设计。即上一章提到的允许在事务提交之前提前写入数据，理论上肯定是写到了内存中，并且记录到undolog里面，虽然还不太情况事务的提交真正干了什么操作，但目前来，在内存是可以读到已经修改好的数据。&lt;/p>
&lt;p>2.为什么可以读到已经加了写锁的数据&lt;/p>
&lt;p>原因是读未提交读取数据是不加读锁的，而写锁只能防止其他事物不能加读锁和写锁，而不能防止没有锁 也可以看一下&lt;a class="link" href="https://www.cnblogs.com/henuqin/articles/16533094.html" target="_blank" rel="noopener"
>这篇博客&lt;/a>的解释&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">show&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;transaction%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">global&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">isolation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">read&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">uncommitted&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="err">设置完之后要重新登录&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">varchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">---read uncommitted---
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">读未提交&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">查询结果为&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">test&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">两个事务都是写事务，晚开启的事务更新会阻塞&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;newTest&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transaction_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Test&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="o">`=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">（会阻塞，一直在执行中）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">（在事务&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err">提交成功后，事务&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err">的更新立马就成功了&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">console2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">commit&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考资料">参考资料：
&lt;/h2>&lt;p>&lt;a class="link" href="https://time.geekbang.org/column/article/319988" target="_blank" rel="noopener"
>12 | 本地事务如何实现隔离性？-极客时间&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://time.geekbang.org/column/article/68963" target="_blank" rel="noopener"
>03 | 事务隔离：为什么你改了我还看不见？-极客时间&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/henuqin/articles/16533094.html" target="_blank" rel="noopener"
>读未提交-为什么事务没提交就可以读到别人修改的数据 - 秦一居 - 博客园&lt;/a>&lt;/p></description></item></channel></rss>